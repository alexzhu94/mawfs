# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## FUSE interface.

import mawfs.blockstore Node, NodeStore, MODE_DIR;
import crack.cont.hashmap HashMap;
import crack.ext._fuse fuse_main = main, get_context, DoubleTimeSpec,
    FuseOperations, FuseFileInfo;
import crack.fs Path;
import crack.io SeekableReader, SeekableWriter, SEEK_SET;
import crack.lang Buffer, SystemError, WriteBuffer;
import crack.logger info;
import crack.runtime free, memcpy, Stat, EACCES, EEXIST, EINVAL, ENOENT,
    ENOTDIR, O_CREAT, O_RDONLY, S_IFDIR, S_IFREG;
import crack.strutil split, StringArray;
import crack.threads Mutex, MutexLock;
import mawfs.path MAWFSPath;
import mawfs.cache Cache, CachedNode;

const int ENOSYS = 38;

## Stores information on an open file.
class FileInfo {

    ## File Handle.
    uint64 fh;

    SeekableReader reader;
    SeekableWriter writer;

    oper init(uint64 fh, SeekableReader reader, SeekableWriter writer) :
        fh = fh,
        reader = reader,
        writer = writer {
    }
}

## A globally-locked filesystem.
class LockedFilesystem {
    Mutex mutex = {};
    NodeStore store;
    Cache cache;
    CachedNode cachedRoot;
    Path root;
    HashMap[int, FileInfo] files = {};

    oper init(NodeStore store) :
        store = store,
        cache(store) {

        rootDigest := store.getRootDigest();
        rootNode := store.getNode(rootDigest);
        cachedRoot = CachedNode(cache, rootDigest, rootNode);
        root = MAWFSPath(cachedRoot);
    }
}

## A filesystem context.  This is created when we come into a fuse entrypoint
## and must be destroyed when the operation is complete.
class Context {
    LockedFilesystem __fs;
    MutexLock __lock;

    oper init(LockedFilesystem fs) :
        __fs = fs,
        __lock = MutexLock(__fs.mutex) {
    }

    @static Context get() {
        fs := LockedFilesystem.unsafeCast(get_context().private_data);
        context := Context(fs);
        return context;
    }

    ## Get the path object for the fully qualified 'path', return null if
    ## there is none.
    Path getPath(byteptr path) {
        pathStr := String(path);

        # Special case the root directory.
        if (pathStr == '/')
            return __fs.root;

        # Look up the Path object, return null if we get to a non-directory.
        components := split(pathStr, b'/');
        cur := __fs.root;
        for (int i = 1; i < components.count(); ++i) {
            if (cur && cur.isDir())
                cur = cur[components[i]];
            else
                return null;
        }

        return cur;
    }

    FileInfo makeFileInfo(SeekableReader reader, SeekableWriter writer) {
        fh := __fs.files.count() + 1;
        fi := FileInfo(fh, reader, writer);
        __fs.files[fh] = fi;
        return fi;
    }

    FileInfo getFileInfo(uint64 fh) {
        return __fs.files.get(fh);
    }

    void deleteFileInfo(uint64 fh) {
        __fs.files.delete(fh);
    }

    void commit() {
        __fs.store.storeRoot(__fs.cachedRoot.commit());
    }
}

int _getattr(byteptr path, Stat stbuf)
{
    info `in getattr($path, $stbuf)`;
    ctx := Context.get();
    p := ctx.getPath(path);
    if (p && p.exists()) {
        stat := p.getStat();
        stbuf.st_mode = stat.st_mode;
        stbuf.st_nlink = stat.st_nlink;
        stbuf.st_uid = stat.st_uid;
        stbuf.st_gid = stat.st_gid;
        stbuf.st_size = p.getSize();
        return 0;
    } else {
        return -ENOENT;
    }
}

int _readdir(byteptr path, voidptr buf,
             function[int, voidptr, byteptr, Stat, uintz] filler,
             uintz offset,
             FuseFileInfo fi
             ) {
    info `in readdir($path, buf, filler, $offset, $fi)`;
    ctx := Context.get();
    if (p := ctx.getPath(path)) {
        filler(buf, ".".buffer, null, 0);
        filler(buf, "..".buffer, null, 0);

        # Fill in all of the child entries.
        for (item :in p.children())
            filler(buf, item.getName().buffer, item.getStat(), 0);

        return 0;
    } else {
        return -ENOENT;
    }
}

int _open(byteptr path, FuseFileInfo fi) {
    info `in open($path, $fi)`;
    ctx := Context.get();
    p := ctx.getPath(path);
    if (p && !p.isDir()) {
        fi.fh = ctx.makeFileInfo(p.reader(), null).fh;
        return 0;
    } else {
        return -ENOENT;
    }
}

int _read(byteptr path, byteptr buf, uintz size, uintz offset,
          FuseFileInfo fi
          ) {
    info `in read($path, buf, $size, $offset, $fi)`;
    ctx := Context.get();
    info := ctx.getFileInfo(fi.fh);
    if (!((info ? info.reader : null) is null)) {
        WriteBuffer temp = {buf, 0, size};
        return info.reader.read(temp);
    } else {
        return -EINVAL;
    }
}

int _write(byteptr path, byteptr buf, uintz size, uintz offset,
           FuseFileInfo fi
           ) {
    info `in write($path, buf, $size, $offset, $fi)`;
    ctx := Context.get();
    info := ctx.getFileInfo(fi.fh);
    if (info && info.writer) {
        info.writer.seek(uintz(offset), SEEK_SET);
        info.writer.write(Buffer(buf, size));
        return size;
    } else {
        return -EINVAL;
    }
}

int _flush(byteptr path, FuseFileInfo fi) {
    info `in flush($path, $fi)`;
    ctx := Context.get();
    info := ctx.getFileInfo(fi.fh);
    if (info) {
        if (info.writer)
            info.writer.flush();
        return 0;
    } else {
        return -ENOENT;
    }
}

int _readlink(byteptr path, byteptr buffer, intz size) {
    info `readlink not implemented\n`;
    return -ENOSYS;
}

int _truncate(byteptr path, uintz size) {
    info `in truncate($path, $size)`;
#    ctx := Context.get(path);
#    if (node := ctx.lookUp())
#        return node.truncate(ctx, size);
#    else
        return -ENOENT;
}

int _ftruncate(byteptr path, uintz size, FuseFileInfo fi) {
    info `in ftruncate($path, $size)`;
#    ctx := Context.get(path);
#    if (node := ctx.lookUp())
#        return node.ftruncate(ctx, size, fi);
#    else
        return -ENOENT;
}

int _mknod(byteptr path, int major, int minor) {
    info `mknod not implemented`;
    return -ENOSYS;
}

int _create(byteptr path, int mode, FuseFileInfo fi) {
    info `in create($path, mode, $fi)`;
    ctx := Context.get();
    p := ctx.getPath(path);
    if (p) {
        fi.fh = ctx.makeFileInfo(null, p.writer()).fh;
        return 0;
    } else {
        return -ENOENT;
    }
}

int _mkdir(byteptr path, int mode) {
    info `in mkdir($path, $mode)`;
    ctx := Context.get();
    p := ctx.getPath(path);
    if (p) {
        try {
            p.makeDir();
            return 0;
        } catch (SystemError ex) {
            # TODO: return error code from ex.
            info `exception in mkdir: $ex`;
            return -EINVAL;
        }
    } else {
        return -ENOENT;
    }
}

int _chmod(byteptr path, int mode) {
    info `in chmod($path, $mode)`;
#    ctx := Context.get(path);
#    if (node := ctx.lookUp())
#        return node.chmod(ctx, mode);
#    else
        return -ENOENT;
}

int _access(byteptr path, int uid) {
    info `in access($path, $uid)`;
    return 0;
}

int _rename(byteptr path, byteptr newPath) {
    info `in rename($path, $newPath)`;
    ctx := Context.get();
    p0 := ctx.getPath(path);
    p1 := ctx.getPath(newPath);
    if (!p0 || !p0.exists() || !p1 || !p1.parent().exists())
        return -ENOENT;
    p0.moveTo(p1);
    return 0;
}

int _chown(byteptr path, int uid, int gid) {
    info `in chown($path, $uid, $gid)\n `;
#    ctx := Context.get(path);
#    if (node := ctx.lookUp())
#        return node.chown(ctx, uid, gid);
#    else
        return -ENOENT;
}

int _utimens(byteptr path, DoubleTimeSpec times) {
    info `in utimens($path, times)`;
    # We don't currently have support for this at just about any level.
    return 0;
}

int _release(byteptr path, FuseFileInfo fi) {
    info `in release($path, $fi)`;
    ctx := Context.get();
    if (ctx.getFileInfo(fi.fh)) {
        ctx.deleteFileInfo(fi.fh);
        return 0;
    } else {
        return -EINVAL;
    }
}

int _fsyncdir(byteptr path, int datasync, FuseFileInfo fi) {
    info `in fsyncdir($path, $datasync, $fi)`;
    ctx := Context.get();
    ctx.commit();
    return 0;
}

## Does fuse_main().  Do this if you're implementing a simple
## filesystem-per-process.
int main(StringArray argv, LockedFilesystem fs) {
    ops := FuseOperations();
    ops.getattr = _getattr;
    ops.readdir = _readdir;
    ops.open = _open;
    ops.read = _read;
    ops.write = _write;
    ops.flush = _flush;
    ops.truncate = _truncate;
    ops.ftruncate = _ftruncate;
    ops.readlink = _readlink;
    ops.mknod = _mknod;
    ops.create = _create;
    ops.mkdir = _mkdir;
    ops.chmod = _chmod;
    ops.rename = _rename;
    ops.chown = _chown;
    ops.utimens = _utimens;
    ops.release = _release;
    ops.fsyncdir = _fsyncdir;

    # Create another link to the root object so we can safely exit.
    fs.root.oper bind();
    return fuse_main(argv.count(), argv.makePrimArray(), ops, fs);
}

void runFuse(NodeStore store, StringArray argv) {

    # Get the existing root node or create one if this is an empty filesystem.
    rootNode := store.getRoot();
    if (!rootNode) {
        rootNode = Node();
        rootNode.mode = MODE_DIR;
        store.storeRoot(store.storeNode(rootNode));
    }

    main(argv, LockedFilesystem(store));
}
