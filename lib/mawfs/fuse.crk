
import crack.ascii hex;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.ext._fuse FuseFileInfo;
import crack.exp.fuse log, main, Context, FuseNode = Node, NodeImpl, LockedFilesystem;
import crack.io cerr, Formatter;
import crack.lang AssertionError, Buffer, Exception, ManagedBuffer, WriteBuffer;
import crack.runtime free, Stat, S_IFDIR, S_IFREG;
import crack.strutil StringArray;
import mawfs.blockstore Entry, Node, NodeStore, MODE_DIR, MODE_EXE;

uintz min(uintz a, uintz b) {
    return (a < b) ? a : b;
}

## BlockIter lets you read and write to certain positions in a BlockStore node.
## Note: this may not be a very good abstraction considering the way that
## we're using it.
class BlockIter {
    Array[Node] nodeStack = {};
    uintz pos;

    oper init(Node target) { nodeStack.append(target); }

    void setPos(uintz newPos) {
        Node target = nodeStack[-1];
        if (target.contents) {
            if (pos < target.contents.size)
                pos = newPos;
            else
                pos = target.contents.size;
        } else {
            pos = 0;
        }

        # TODO: deal with "elems"
    }

    int read(WriteBuffer result) {
        Node target = nodeStack[-1];
        if (!target.contents)
            return 0;
        size := min(target.contents.size - pos, result.cap);
        result.move(0, target.contents.buffer + pos, size );
        # TODO: deal with elems.
        return size;
    }

    int write(Buffer data) {
        Node target = nodeStack[-1];
        if (target.contents) {
            if (pos <= target.contents.size) {
                ManagedBuffer resultBuf = {
                    (target.contents.size > pos + data.size) ?
                        target.contents.size :
                        pos + data.size
                };

                # Copy in the original data and the new data.
                resultBuf.move(0, target.contents);
                resultBuf.move(pos, data);

                target.contents = String(resultBuf, true);
            } else {
                # It looks like a write() a position greater than the current size
                # of the file resizes the file and pads with zeroes up to the
                # write position.
                throw AssertionError('Implement writes greater than size.');
            }
        } else {
            target.contents = String(data);
        }
        return data.size;
    }
}

## A MAWFS filesystem node.
class MAWFSNode : NodeImpl {
    NodeStore __store;
    Node __rep;
    MAWFSNode __parent;
    bool isRoot;

    class Child {
        ## The digest of the child node.
        String digest;

        ## Index of the child in its parent.
        int index;

        ## The MAWFS node of the child, may be null if the child hasn't been
        ## loaded.
        MAWFSNode node;

        oper init(String digest, int index) : digest = digest, index = index {}

        void formatTo(Formatter out) {
            out `MAWFSNode.Child($(hex(digest)), $index)`;
        }
    }
    alias ChildMap = HashMap[String, Child];
    ChildMap __children;

    ## The index of the node in it's parent's list.
    int __indexInParent;

    oper init(NodeStore store, Node rep) :
        NodeImpl(040777, 1),
        __store = store,
        __rep = rep,
        __parent = null {
    }

    oper init(MAWFSNode parent, Node rep) :
        NodeImpl(040777, 1),
        __store = parent.__store,
        __rep = rep,
        __parent = parent {
    }

    ## Gets the dictionary of children, populating it if necessary.
    ChildMap __getChildren() {
        if (__children is null) {
            __children = ChildMap();

            int i;
            for (child :in __rep.children)
                __children[child.name] = Child(child.hash, i++);
        }
        return __children;
    }

    ## Returns the size of the underlying node.
    uintz __getSize() {
        if (__rep.contents)
            # TODO: make this work for nested nodes.
            return __rep.contents.count();
        else
            return 0;
    }

    ## Rewrite a parent node after changing the digest of a child.
    void __changeChild(StringArray name, int index, String digest) {
        child := __getChildren().get(name[index]);
        if (!child) {
            log I`Error: directory $(name.subarray(0, index)) does not have \
                  child $(name[index])\n`;
            return;
        }

        if (child.digest == digest)
            return;

        child.digest = digest;
        __rep.children[child.index].hash = digest;
        myDigest := __store.storeNode(__rep);

        if (__parent)
            __parent.__changeChild(name, index - 1, myDigest);
        else
            __store.storeRoot(myDigest);
    }

    void __changeChild(Context ctx, String digest) {
        __changeChild(ctx.parsedPath, ctx.parsedPath.count() - 1, digest);
    }

    ## For testing only.
    void setRep(Node rep) {
        __rep = rep;
    }

    int readdir(Context ctx, voidptr buf,
                function[int, voidptr, byteptr, Stat, uintz] filler,
                uintz offset,
                FuseFileInfo fi
                ) {
        Stat stat = {};
        stat.st_mode = 040777;

        filler(buf, ".".buffer, null, 0);
        filler(buf, "..".buffer, null, 0);

        stat.st_mode = 040777;
        stat.st_nlink = 1;
        stat.st_uid = 0;
        stat.st_gid = 0;
        for (child :in __rep.children) {
            filler(buf, child.name.buffer, stat, 0);
        }

        free(stat);
        return 0;
    }

    int open(Context ctx, FuseFileInfo fi) {
        return 0;
    }

    int read(Context ctx, byteptr buf, uintz size, uintz offset,
             FuseFileInfo fi
             ) {
        iter := BlockIter(__rep);
        iter.setPos(offset);
        return iter.read(WriteBuffer(buf, size));
    }

    int write(Context ctx, byteptr buf, uintz size, uintz offset,
              FuseFileInfo fi
              ) {
        iter := BlockIter(__rep);
        iter.setPos(offset);
        result := iter.write(Buffer(buf, size));

        digest := __store.storeNode(__rep);
        if (__parent)
            __parent.__changeChild(ctx, digest);

        return result;
    }

    void __makeChild(Context ctx, int mode) {
        # Create a new node and store it.
        node := Node();
        node.mode = int32(mode);
        digest := __store.storeNode(node);
        name := ctx.parsedPath[-1];

        children := __getChildren();
        child := children.get(name);
        if (child) {
            __rep.children[child.index].hash = digest;
        } else {
            entry := Entry();
            entry.name = name;
            entry.hash = digest;
            children[name] = Child(digest, __rep.children.count());
            __rep.children.append(entry);
        }

        myDigest := __store.storeNode(__rep);
        if (__parent) {
            __parent.__changeChild(ctx.parsedPath, ctx.parsedPath.count() - 2,
                                   myDigest
                                   );
        } else {
            __store.storeRoot(myDigest);
        }
    }

    int create(Context ctx, int mode, FuseFileInfo fi)  {
        __makeChild(ctx, (mode & 0111) ? MODE_EXE : 0);
        return 0;
    }

    int mkdir(Context ctx, int mode) {
        __makeChild(ctx, MODE_DIR);
        return 0;
    }

    int getattr(Context ctx, Stat stbuf) {
        mode := 0666;
        if (__rep.mode & MODE_EXE)
            mode |= 0111;
        if (__rep.mode & MODE_DIR)
            mode |= S_IFDIR | 0111;
        else
            mode |= S_IFREG;
        stbuf.st_mode = mode;
        stbuf.st_nlink = 1;
        stbuf.st_uid = 1000;
        stbuf.st_gid = 1000;
        stbuf.st_size = __getSize();
        return 0;
    }

    int truncate(Context ctx, uintz size) {
        if (__rep.contents && __rep.contents.size > size) {
            __rep.contents = __rep.contents.substr(0, size);

            digest := __store.storeNode(__rep);

            if (__parent)
                __parent.__changeChild(ctx, digest);
        }

        return 0;
    }

    int ftruncate(Context ctx, uintz size, FuseFileInfo fi) {
        return truncate(ctx, size);
    }

    FuseNode lookUp(StringArray parsedPath, int start, int end) {
        if (start == end)
            return this;

        children := __getChildren();
        child := children.get(parsedPath[start]);
        if (child) {
            mawfsChild := MAWFSNode(this, __store.getNode(child.digest));
            return mawfsChild.lookUp(parsedPath, start + 1, end);
        } else {
            return null;
        }
    }
}

void runFuse(NodeStore store, StringArray argv) {

    # Get the existing root node or create one if this is an empty filesystem.
    rootNode := store.getRoot();
    if (!rootNode) {
        rootNode = Node();
        rootNode.mode = MODE_DIR;
        store.storeRoot(store.storeNode(rootNode));
    }
    main(argv, LockedFilesystem(MAWFSNode(store, rootNode)));
}
