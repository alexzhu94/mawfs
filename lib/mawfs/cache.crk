## The node cache.
module;

import crack.ascii hex;
import crack.io cerr;
import crack.cont.array Array;
import crack.logger debug;
import mawfs.blockstore Entry, Node, NodeStore;


class Cache {
    ## The raw cached blocks.
#    HashMap[String, Node] blcoks;
}

class CachedNode {
    String digest;
    Node node;

    ## The parent node (the directory that this node is in).
    CachedNode parent;

    class CachedEntry {
        Entry entry;
        CachedNode node;

        oper init(Entry entry, CachedNode node) : entry = entry, node = node {}

        @final String getName() {
            return entry.name;
        }

        @final String getDigest() {
            return entry.hash;
        }

        @final void setDigest(String digest) {
            entry.hash = digest;
        }
    }

    # A sparse-array version of Node.children.  These get filled in as they
    # are accessed.
    Array[CachedEntry] __children;

    oper init(String digest, Node node) :
        digest = digest,
        node = node {
    }

    ## Get a child by its index.
    CachedNode getChild(NodeStore store, uint index) {
        CachedEntry cachedEntry;
        if (!__children)
            # Create an array of children to mirror that of node.children,
            # initialize all elements to null.
            __children = Array[CachedEntry](node.children.count(), null);
        else
            cachedEntry = __children[index];
        if (!cachedEntry) {
            entry := node.children[index];
            cachedEntry = __children[index] =
                CachedEntry(entry, CachedNode(entry.hash,
                                              store.getNode(entry.hash)
                                              )
                            );
        }
        return cachedEntry.node;
    }

    @final String getContents() {
        return node.contents;
    }

    ## Find the index of a named child within a range. (Does a binary search
    ## in __children).
    @final uint __findIndex(String name, uint start, uint end) {
        uint midpoint = (end - start) / 2 + start;
        if (midpoint == start) {
            if (name < __children[midpoint].getName())
                return start;
            else
                return end;
        }

        if (name == __children[midpoint].getName())
            return midpoint;

        if (name < __children[midpoint].getName())
            return __findIndex(name, start, midpoint);
        else
            return __findIndex(name, midpoint, end);
    }

    ## Mark the node as diry by removing its digest and do the same for all
    ## parent nodes.
    void __markDirty() {

        # Find the child in the parent and invalidate all instances.
        if (parent) {
            for (child :in parent.__children) {
                if (child.entry is this || child.getDigest() == digest)
                    child.setDigest(null);
            }
        }

        digest = null;
        if (parent) parent.__markDirty();
    }

    ## Add a new child node with the specified name.
    void addChild(String name, Node node) {
        child := CachedNode(null, node);
        child.parent = this;

        CachedEntry entry = {Entry(), child};
        entry.entry.name = name;

        i := __findIndex(name, 0, __children.count());
        if (i < __children.count() && name == __children[i].getName())
            __children[i] = entry;
        else
            __children.insert(i, entry);

        # Mark the node and the entire ancestor chain as dirty.
        __markDirty();
    }

    ## Commit all outstanding changes in the tree.  Returns the new digest.
    String commit(NodeStore store) {
        # If our digest is up to date, we don't need to do anything.
        if (digest)
            return digest;

        if (__children) {
            # Commit all dirty children and reconstruct the child list for the
            # underlying node.

            # Create a new list of children for the node.
            node.children = Array[Entry](__children.count());

            for (child :in __children) {
                if (!child.getDigest())
                    child.setDigest(child.node.commit(store));
                node.children.append(child.entry);
            }
        } else {
            # Make sure our node also has no children.
            node.children = null;
        }

        # Commit the node itself.
        digest = store.storeNode(node);
        return digest;
    }
}
