## The node cache.
module;

import crack.ascii hex;
import crack.io cerr, FStr;
import crack.cont.array Array;
import crack.lang cmp, AssertionError, makeHashVal;
import crack.logger debug, error;
import crack.protobuf readMessageFromString, Field, Message, ProtoWriter;
import mawfs.blockstore Entry, Node, NodeStore;

@import crack.ann assert, impl;
@import crack.protobuf.ann protobuf;

const int32
    ## Add child (contains a Node and a name)
    CHANGE_ADD_CHILD = 1,

    ## Make a change to a nested child.  Contains a 'name' (the name of the
    ## child) and the 'nested' field containing the change to be applied to
    ## that child.
    CHANGE_NESTED = 2;

@protobuf {
    declare Node;

    message Change {
        ## Types are the CHANGE_* constants.
        required int32 type = 1;

        ## Child name.
        optional string name = 2;

        ## Node to be added.
        optional Node node = 3;

        ## Change to be applied to a nested child (should be another Changes
        ## message).
        optional bytes nested = 4;
    }
}

class Cache {
    ## The raw cached blocks.
#    HashMap[String, Node] blcoks;

    NodeStore store;

    oper init(NodeStore store) : store = store {}

    @final void addChange(String digest, Change change) {
        store.writeToJournal(digest, change.toString());
    }

    @final String storeNode(Node node) {
        return store.storeNode(node);
    }

    @final Node getNode(String digest) {
        return store.getNode(digest);
    }

    @final void clearJournal(String digest) {
        store.deleteJournal(digest);
    }

    @final Array[Change] getJournalEntries(String digest) {
        unparsedChanges := store.getJournalEntries(digest);
        Array[Change] changes = {};
        for (serializedChange :in unparsedChanges) {
            Change parsedChange = {};
            readMessageFromString(parsedChange, serializedChange);
            changes.append(parsedChange);
        }
        return changes;
    }
}

class CachedNode;

## Returns an up-to-date (i.e. the journal has been replayed) cached node
## from the cache.
CachedNode _getCachedNode(Cache cache, String digest);

class CachedNode {
    Cache __cache;

    String digest;
    Node node;
    bool dirty;

    ## The parent node (the directory that this node is in).
    CachedNode parent;

    @final int getMode() {
        return node.mode;
    }

    class CachedEntry {
        Entry entry;
        Cache __cache;
        CachedNode node;

        oper init(Cache cache, Entry entry) :
            entry = entry,
            __cache = cache {
        }

        oper init(Entry entry, CachedNode node) : entry = entry, node = node {
            # We shouldn't really need the cache if we've already got the
            # node, but this gives us a clean invariant.
            __cache = node.__cache;
        }

        @final String getName() {
            return entry.name;
        }

        @final String getDigest() {
            return entry.hash;
        }

        @final void setDigest(String digest) {
            entry.hash = digest;
        }

        ## Returns the node referenced by this child object.
        @final CachedNode getNode() {
            # Lazy load the node.
            if (!node)
                node = _getCachedNode(__cache, entry.hash);
            return node;
        }

        @final int getMode() {
            return getNode().getMode();
        }
    }

    ## A list of children sorted by name.  Retrieval/insertion by name is
    ## supported.
    class __ChildArray : Array[CachedEntry] {

        oper init(uint size, CachedEntry default) :
            Array[CachedEntry](size, default) {
        }

        ## Recursive helper for __findIndex(String).
        @final int __findIndex(String name, uint start, uint end) {

            if (!count())
                return -1;

            uint midpoint = (end - start) / 2 + start;
            if (midpoint == start) {
                comparison := cmp(name, this[midpoint].getName());
                if (comparison == 0)
                    return start;
                else if (comparison < 0)
                    return -(start + 1);
                else
                    return -(end + 1);
            }

            if (name == this[midpoint].getName())
                return midpoint;

            if (name < this[midpoint].getName())
                return __findIndex(name, start, midpoint);
            else
                return __findIndex(name, midpoint, end);
        }

        ## Find the index of the child with the given name.  If there is no
        ## match in the array, returns the
        ## negative index + 1 of where the element would be (so if it belonged
        ## at index 0, we would return -1).  Returns the index of the element
        ## if it was found as an ordinary positive integer.
        @final int findIndex(String name) {
            return __findIndex(name, 0, count());
        }

        ## Return the entry identified by the name, null if it doesn't exist.
        @final CachedEntry get(String name) {
            i := __findIndex(name, 0, count());
            if (i < 0)
                return null;
            else
                return this[i];
        }

        @final void add(CachedEntry entry) {
            i := findIndex(entry.getName());
            if (i >= 0)
                this[i] = entry;
            else
                insert(-i - 1, entry);
        }
    }

    # A sparse-array version of Node.children.  These get filled in as they
    # are accessed.
    __ChildArray __children;

    ## digest should be null for a new node.
    oper init(Cache cache, String digest, Node node) :
        __cache = cache,
        digest = digest,
        node = node,
        dirty = !digest {
    }

    ## Allocate __children array to mirror the values in node.children.
    @final void __makeChildren() {
        # Create an array of children to mirror that of node.children,
        # initialize all elements to null.
        __children = __ChildArray(node.children.count(), null);
    }


    ## Allocate an array of children and populate with the child entries in
    ## the node.
    @final void __populateChildren() {
        if (!__children)
            __makeChildren();
        if (node.children) {
            for (iter :on node.children)
                __children[iter.index] = CachedEntry(__cache, iter.elem());
        }
    }

    ## Get a child by its index.
    CachedNode getChild(uint index) {
        CachedEntry cachedEntry;
        if (!__children)
            __makeChildren();
        else
            cachedEntry = __children[index];
        if (!cachedEntry) {
            entry := node.children[index];
            cachedEntry = __children[index] =
                CachedEntry(entry,
                            CachedNode(__cache, entry.hash,
                                       __cache.getNode(entry.hash)
                                       )
                            );
        }
        return cachedEntry.node;
    }

    @final String getContents() {
        return node.contents;
    }

    ## Mark the node as diry and do the same for all parent nodes.
    void __markDirty() {

        # Find the child in the parent and invalidate all instances.
        if (parent) {
            for (child :in parent.__children) {
                if (child.entry is this || child.getDigest() == digest)
                    child.setDigest(null);
            }
        }

        dirty = true;
        if (parent) parent.__markDirty();
    }

    void __recordChildChange(CachedNode child, Change childChange) {

        # Find the name of the child.
        String childName;
        for (c :in __children) {
            if (c.node is child)
                childName = c.getName();
        }

        @assert(childName);

        # Create a change for the child.
        change := Change();
        change.type = CHANGE_NESTED;
        change.name = childName;
        change.nested = childChange.toString();
        if (digest) {
            __cache.addChange(digest, change);
        } else {
            @assert(parent);
            __recordChildChange(this, change);
        }

    }

    ## Internal add child method, which does everything but create a change
    ## record.
    void __addChild(String name, Node node) {
        child := CachedNode(__cache, null, node);
        child.parent = this;

        CachedEntry entry = {Entry(), child};
        entry.entry.name = name;

        if (__children is null)
            # TODO: we can get away with lazy-populating the child entries.
            __populateChildren();

        # Add the child.
        __children.add(entry);

        # Mark the node and the entire ancestor chain as dirty.
        __markDirty();
    }

    ## Add a new child node with the specified name.
    void addChild(String name, Node node) {
        __addChild(name, node);

        # Record the change in the journal.
        change := Change();
        change.type = CHANGE_ADD_CHILD;
        change.name = name;
        change.node = node;

        # If we have a digest, we can create a change record against this
        # node.  If not, we have to recurse back to the first parent that has
        # a digest and apply the change to its journal.
        if (digest) {
            __cache.addChange(digest, change);
        } else {
            @assert(parent);
            parent.__recordChildChange(this, change);
        }
    }

    ## Commit all outstanding changes in the tree.  Returns the new digest.
    String commit() {
        # If our digest is up to date, we don't need to do anything.
        if (!dirty)
            return digest;

        if (__children) {
            # Commit all dirty children and reconstruct the child list for the
            # underlying node.

            # Create a new list of children for the node.
            node.children = Array[Entry](__children.count());

            for (child :in __children) {
                if (!child.getDigest())
                    child.setDigest(dig := child.node.commit());
                node.children.append(child.entry);
            }
        } else {
            # Make sure our node also has no children.
            node.children = null;
        }

        # Commit the node itself and clear the journal.
        orgDigest := digest;
        if (__children) {
            for (child :in __children) {
                if (!child.entry.hash)
                    throw AssertionError(
                        FStr() `Invalid hash for $(child.getName())`
                    );
                else if (!child.entry.name)
                    throw AssertionError(FStr() `Child with no name`);
            }
        }

        digest = __cache.storeNode(node);
        dirty = false;
        __cache.clearJournal(orgDigest);

        return digest;
    }

    void __applyChange(Change change) {
        if (change.type == CHANGE_ADD_CHILD) {
            __addChild(change.name, change.node);
        } else if (change.type == CHANGE_NESTED) {

            # Get the requested child.
            child := __children.get(change.name);
            if (!child) {
                error I`Change for child $(change.name) of node $digest \
                        found, but child doesn't exist.`;
                return;
            }

            # Extract the neste change and apply it to the child.
            Change nested = {};
            readMessageFromString(nested, change.nested);
            child.getNode().__applyChange(nested);
        }
    }

    ## Replay all journal entries against the node.  If the node doesn't have
    ## a digest or there are no changes, does nothing.
    void replayJournal() {

        # Don't do this for a node that hasn't been saved.
        if (!digest)
            return;

        changes := __cache.getJournalEntries(digest);
        if (!changes)
            return;

        # Apply all of the changes in sequence.
        for (change :in changes)
            __applyChange(change);
    }
}

CachedNode _getCachedNode(Cache cache, String digest) {
    node := CachedNode(cache, digest, cache.getNode(digest));
    node.replayJournal();
    return node;
}
