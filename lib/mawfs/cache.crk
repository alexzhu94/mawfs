# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## The node cache.
module;

import crack.enc.base64 altEncode;
import crack.cont.hashmap HashMap;
import crack.io.fmtutil Indenter;
import crack.io Formatter, FStr, Writer;
import crack.cont.array Array;
import crack.lang cmp, AppendBuffer, AssertionError, Buffer, Exception,
    InvalidArgumentError, InvalidStateError, KeyError, ManagedBuffer,
    WriteBuffer, makeHashVal;
import crack.logger debug, error, info;
import crack.strutil StringArray;
import mawfs.blockstore Entry, Change, Commit, JournalIter, Node, NodeStore,
    MODE_DIR;
import mawfs.chunker RabinChunker, DEFAULT_WINDOW_SIZE;

@import crack.ann assert, impl, struct;

String snippet(String content) {
    if (content.size > 10)
        return content.substr(0, 10).getRepr();
    else
        return content.getRepr();
}

# Allow initial blocks of up to one meg.
const DEFAULT_MAX_CONTENT_SIZE := 1024 * 1024;
const DEFAULT_MAX_CHILDREN := 256;
const DEFAULT_MAX_JOURNAL_SIZE := 16 * 1024 * 1024;

const int32
    ## Add child (contains a Node and a name)
    CHANGE_ADD_CHILD = 1,

    ## Delete a child (contains a name).
    CHANGE_DELETE_CHILD = 2,

    ## Write data to node contents (respecting all current rules about file
    ## size, layout etc).  Contains pos and data.
    CHANGE_WRITE = 3,

    ## Resize node contents.  Contains newSize.
    CHANGE_RESIZE = 4;

class Cache {
    NodeStore store;

    ## The digest of the last commit.  Changes in the journal are relative to
    ## this.
    String baselineCommit;

    ## The digest of the last change.
    String lastChange;

    ## The name of the branch.  "master" is the default branch.
    String branch;

    uint maxContentSize = DEFAULT_MAX_CONTENT_SIZE;
    uint maxChildren = DEFAULT_MAX_CHILDREN;
    uint maxJournalSize = DEFAULT_MAX_JOURNAL_SIZE;

    oper init(NodeStore store, String branch, String baselineCommit) :
        store = store,
        branch = branch,
        baselineCommit = baselineCommit {
    }

    @final void addChange(Change change) {
        if (lastChange) {
            change.lastChange = lastChange;
        } else {
            change.commit = baselineCommit;
        }
        lastChange = store.writeToJournal(branch, change);
    }

    ## Returns true if the caller should commit.
    @final bool shouldCommit() {
        return store.getJournalSize(branch) >= maxJournalSize;
    }

    @final String storeNode(Node node) {
        return store.storeNode(node);
    }

    @final Node getNode(String digest) {
        return store.getNode(digest);
    }

    @final void clearJournal() {
        store.deleteJournal(branch);
    }

    @final JournalIter makeJournalIter() {
        return store.makeJournalIter(branch);
    }

    ## Records the digest of a new commit.
    @final void recordCommit(String commit) {
        lastChange = null;
        baselineCommit = commit;
    }
}

class CachedNode;

## Creates a CachedNode.
CachedNode _makeCachedNode(CachedNode parent, Cache cache, String digest);

## Wraps a Node object with caching functionality.
class CachedNode {
    Cache __cache;

    String digest;
    Node node;

    ## Indicates that a node has been changed in memory and in the transaction
    ## log but needs to be committed.  A dirty node is assumed to have an
    ## invalid digest.  Likewise, a non-dirty node is assumed to have a valid
    ## digest.  All nodes should either be loaded from the block store (in
    ## which case, they have a valid digest) or created as part of an
    ## operation (in which case they should have no digest and be dirty).
    bool dirty;

    ## The parent node (the directory that this node is in).
    CachedNode parent;

    class VerifyReport;
    VerifyReport verify();

    ## Gets the node's mode.
    @final int getMode() {
        return node.mode;
    }

    @final bool isDir() {
        return node.mode & MODE_DIR;
    }

    @final uint64 getSize();

    class CachedEntry {
        Entry entry;
        Cache __cache;
        CachedNode node;
        CachedNode __parent;

        oper init(Cache cache, Entry entry, CachedNode parent) :
            entry = entry,
            __cache = cache,
            __parent = parent {
        }

        oper init(Entry entry, CachedNode node, CachedNode parent) :
            entry = entry,
            node = node,
            __parent = parent {

            # We shouldn't really need the cache if we've already got the
            # node, but this gives us a clean invariant.
            __cache = node.__cache;
        }

        @final String getName() {
            return entry.name;
        }

        @final String getDigest() {
            return entry.hash;
        }

        @final void setDigest(String digest) {
            entry.hash = digest;
        }

        @final uint64 getSize() {
            return uint64(entry.size);
        }

        ## Returns the node referenced by this child object.
        @final CachedNode getNode() {
            # Lazy load the node.
            if (!node) {
                if (!entry.hash)
                    throw InvalidStateError(
                        FStr() `No hash or node for $(entry.name)`
                    );
                node = _makeCachedNode(__parent, __cache, entry.hash);
            }
            return node;
        }

        @final int getMode() {
            return getNode().getMode();
        }

        @final CachedNode getParent() { return __parent }
        @final void setParent(CachedNode parent) {
            __parent = parent;
            if (node)
                node.parent = parent;
        }

        @final void setCachedNode(CachedNode node) {
            this.node = node;
            entry.size = node.getSize();
            entry.hash = null;
        }

        ## Set the size in the entry to the size of the referenced node.
        @final void fixSize() {
            entry.size = getNode().getSize();
        }

        void formatTo(Formatter out) {
            indent := Indenter.wrap(out);
            dig := getDigest();
            String digest;
            if (dig)
                digest := altEncode(dig);
            name := getName();
            if (name is null)
                out `-   `;
            else
                out I`$(name.getRepr()):\n`;
            ++indent;
            out I`digest: $(digest ? altEncode(digest) : 'null')
                  size: $(getSize())
                  node: `;
            out `$(node)\n`;
            --indent;
        }
    }

    ## A list of children sorted by name.  Retrieval/insertion by name is
    ## supported.
    ## node.children must exist for this to be created.
    class __ChildArray {

        # Underlying representation (stored in the Node).
        Array[Entry] __rep;

        # Cached entries.
        Array[CachedEntry] __cached;

        oper init(Array[Entry] rep) :
            __rep = rep,
            __cached(rep.count(), null) {
        }

        ## Recursive helper for __findIndex(String).
        @final int __findIndex(String name, uint start, uint end) {

            if (!__cached.count())
                return -1;

            uint midpoint = (end - start) / 2 + start;
            if (midpoint == start) {
                comparison := cmp(name, __cached[midpoint].getName());
                if (comparison == 0)
                    return start;
                else if (comparison < 0)
                    return -(start + 1);
                else
                    return -(end + 1);
            }

            if (name == __cached[midpoint].getName())
                return midpoint;

            if (name < __cached[midpoint].getName())
                return __findIndex(name, start, midpoint);
            else
                return __findIndex(name, midpoint, end);
        }

        ## Find the index of the child with the given name.  If there is no
        ## match in the array, returns the
        ## negative index + 1 of where the element would be (so if it belonged
        ## at index 0, we would return -1).  Returns the index of the element
        ## if it was found as an ordinary positive integer.
        @final int findIndex(String name) {
            return __findIndex(name, 0, __cached.count());
        }

        ## Return the entry identified by the name, null if it doesn't exist.
        @final CachedEntry get(String name) {
            i := __findIndex(name, 0, __cached.count());
            if (i < 0)
                return null;
            else
                return __cached[i];
        }

        ## Adds a child to the array by order of name.
        @final void add(CachedEntry entry) {
            i := findIndex(entry.getName());
            if (i >= 0) {
                __cached[i] = entry;
                __rep[i] = entry.entry;
            } else {
                __cached.insert(-i - 1, entry);
                __rep.insert(-i - 1, entry.entry);
            }
        }

        @final bool delete(String name) {
            i := findIndex(name);
            if (i >= 0) {
                __cached.delete(i);
                __rep.delete(i);
                return true;
            } else {
                return false;
            }
        }

        ## Deletes a child by index.
        @final void delete(uint index) {
            __cached.delete(index);
            __rep.delete(index);
        }

        @final void append(CachedEntry entry) {
            __cached.append(entry);
            __rep.append(entry.entry);
        }

        @final void insert(uint index, CachedEntry entry) {
            __cached.insert(index, entry);
            __rep.insert(index, entry.entry);
        }

        @final uint count() {
            return __cached.count();
        }

        @final CachedEntry oper [](int index) {
            return __cached[index];
        }

        @final CachedEntry oper []=(int index, CachedEntry entry) {
            return __cached[index] = entry;
        }

        @final Array[CachedEntry].ArrayIter iter() { return __cached.iter() }

        ## Returns the underlying array of entries.  Caller must not modify
        ## its contents directly.
        @final Array[Entry] getRep() { return __rep }

        void formatTo(Formatter out) {
            out `CachedEntries![\n`;
            for (child :in __cached)
                out `$child\n`;
            out `]`;
        }

        bool isTrue() { return __cached }
    }

    # A sparse-array version of Node.children.  These get filled in as they
    # are accessed or when __populateChildren() is called.
    __ChildArray __children;

    ## digest should be null for a new node.
    oper init(Cache cache, String digest, Node node) :
        __cache = cache,
        digest = digest,
        node = node,
        dirty = !digest {
    }

    ## Allocate __children array to mirror the values in node.children.
    ## Creates node.children if it doesn't exist.
    @final void __makeChildren() {
        # First make sure we have node.children.
        if (!node.children)
            node.children = Array[Entry]();

        # Create an array of children to mirror that of node.children,
        # initialize all elements to null.
        __children = __ChildArray(node.children);
    }

    ## Allocate the __children scaffold and populate with the child entries
    ## from the node.
    ## If createEmpty is true, create the scaffold even if node.children is
    ## null, and also create an empty node.children.
    ## If createEmpty is false and children is null or empty, do nothing and
    ## return false.
    ## Return true if the scaffold exists at the end of the method, false if
    ## not.
    @final bool __populateChildren(bool createEmpty) {
        if (!(__children is null))
            return true;
        if (node.children || createEmpty) {
            if (node.children is null)
                node.children = Array[Entry]();
            __makeChildren();
            for (iter :on node.children)
                __children[iter.index] =
                    CachedEntry(__cache, iter.elem(), this);
            return true;
        } else {
            return false;
        }
    }

    CachedEntry __getChildEntry(uint index) {
        CachedEntry cachedEntry;
        if (!__populateChildren(false))
            return null;

        cachedEntry = __children[index];
        if (!cachedEntry) {
            entry := node.children[index];

            node := _makeCachedNode(this, __cache, entry.hash);
            if (!node) {
                error `Unable to load node $(entry.hash)`;
                return null;
            }

            cachedEntry = __children[index] = CachedEntry(entry, node, this);
        }

        return cachedEntry;
    }

    ## Get a child by its index.  Throw IndexError if the index is out of
    ## range.  Return null if we are unable to retrieve the node.
    CachedNode getChild(uint index) {
        cachedEntry := __getChildEntry(index);
        return cachedEntry.getNode();
    }

    ## Returns the name of a child.
    String getChildName(uint index) {
        cachedEntry := __getChildEntry(index);
        return cachedEntry.getName();
    }

    ## Get the child with the given name.  Returns null if there is no such
    ## child.
    @final CachedNode getChild(String name) {
        if (!__populateChildren(false))
            return null;
        child := __children.get(name);
        if (!child)
            return null;
        else
            return child.getNode();
    }


    ## Returns the total size of the node.
    @final uint64 getSize() {
        return node.size;
    }

    @final String getContents() {
        if (!(node.contents is null)) {
            return node.contents;
        } else if (node.children != null) {
            AppendBuffer buf = {getSize()};
            __populateChildren(false);
            for (child :in __children)
                buf.extend(child.getNode().getContents());
            return String(buf, true);
        } else {
            return null;
        }

    }

    ## Returns all ccontent leaf nodes of a given node.  This method is really
    ## just for testing/debugging purposes.
    @final StringArray getChunks() {
        if (!(node.contents is null))
            return StringArray![node.contents];

        @assert(__populateChildren(true));
        StringArray result = {};
        for (child :in __children)
            result.extend(child.getNode().getChunks());
        return result;
    }

    ## Returns true if this is a content node (a leaf).
    @final bool isContentNode() { return node.contents }

    ## Returns the CachedEntry for the child wrapping the node.  Returns
    ## 'null' if undefined.
    @final CachedEntry __getChildEntry(CachedNode node) {
        for (child :in __children) {
            if (child.node is node)
                return child;
        }

        return null;
    }

    ## Mark the node as diry and do the same for all parent nodes.
    void __markDirty() {

        # Find the child in the parent and invalidate all instances.
        if (parent) {
            myEntry := parent.__getChildEntry(this);
            myEntry.setDigest(null);
        }

        dirty = true;
        if (parent) parent.__markDirty();
    }

    void __makePath(Array[int32] path) {
        if (!parent)
            return;

        # Lookup the index of the child (it is always safe to assume
        # __children has been populated for a parent).
        uint i = 0;
        for (child :in parent.__children) {

            # We use .node here instead of getNode(), if the node hasn't been
            # lazy loaded it can't be this one, and we don't want to lazy load
            # any new nodes.
            if (child.node is this)
                break;
            ++i;
        }

        parent.__makePath(path);
        path.append(int32(i));
    }

    CachedNode getRoot();
    String commit();

    ## Commit the entire tree and record a commit object.
    void commitTree() {
        info `committing on branch $(__cache.branch).`;
        newRootDigest := getRoot().commit();
        Commit commit = {};
        commit.root = newRootDigest;
        commit.parent_append(__cache.store.getHead(__cache.branch));

        __cache.store.setHead(__cache.branch,
                              commitDigest := __cache.store.storeCommit(commit))
                              ;
        __cache.recordCommit(commitDigest);
        info I`commit: digest = $(altEncode(commitDigest)), \
               new root = $(altEncode(commit.root))`;
        size := getSize();
    }

    ## Record a change in the journal for this node or for the appropriate
    ## parent node if this node doesn't have a digest yet.
    void __recordChange(Change change) {
        change.path = Array[int32]();
        __makePath(change.path);
        __cache.addChange(change);
        if (__cache.shouldCommit())
            commitTree();
    }

    ## Internal add child method, which does everything but create a change
    ## record.
    CachedNode __addChild(String name, CachedNode child) {
        child.parent = this;

        CachedEntry entry = {Entry(), child, this};
        entry.entry.name = name;

        __populateChildren(true);

        # Add the child.
        __children.add(entry);

        # Mark the node and the entire ancestor chain as dirty.
        __markDirty();

        return child;
    }

    ## Add a new child which is a CachedNode.
    ## You should use this for adding children with cached descendants.
    void addChild(String name, CachedNode child) {
        __addChild(name, child);

        # Record the change in the journal.
        change := Change();
        change.type = CHANGE_ADD_CHILD;
        change.name = name;
        change.node = child.node;
        __recordChange(change);
    }

    ## Add a new child node with the specified name.
    CachedNode addChild(String name, Node node) {
        addChild(name, child := CachedNode(__cache, null, node));
        return child;
    }

    ## Delete the named child and return true, or return false if the child
    ## doesn't exist.
    bool deleteChild(String name) {
        if (!__populateChildren(true))
            return false;
        if (!__children.delete(name))
            return false;

        # Record the change.
        change := Change();
        change.type = CHANGE_DELETE_CHILD;
        change.name = name;
        __recordChange(change);
        __markDirty();

        return true;
    }

    ## Returns the number of children in the node.
    uint getChildCount() {
        return node.children ? node.children.count() : 0;
    }

    ## Returns the root of the cached filesystem.
    CachedNode getRoot() {
        if (!parent)
            return this;
        else
            return parent.getRoot();
    }

    ## Returns the cache object for the node.
    Cache getCache() {
        return __cache;
    }

    ## Make a new unnamed entry for the node parented by 'this'.
    CachedEntry __makeUnnamedEntry(CachedNode node, CachedNode parent) {
        entry := Entry();
        entry.size = node.getSize();
        cachedEntry := CachedEntry(__cache, entry, this);
        cachedEntry.node = node;
        cachedEntry.setParent(parent);
        return cachedEntry;
    }

    ## Split the node if it exceeds the maximum number of children.  If the
    ## node is split, return the new node full of the higher children.
    ## Otherwise return null.
    CachedNode __maybeSplit() {
        if (__children.count() <= __cache.maxChildren)
            return null;

        # Number of nodes in the new first child.
        newSize := __children.count() / 2;

        # Make a copy of the children and reset.
        children := __children;
        __children = null;
        node.children = null;
        node.size = 0;
        __populateChildren(true);

        # Copy the lower children to the receiver.
        int i;
        for (; i < newSize; ++i) {
            __children.append(children[i]);
            node.size += children[i].getSize();
        }

        # Create a new node and copy the higher children.
        CachedNode newNode = {__cache, null, Node()};
        newNode.__populateChildren(true);
        for (; i < children.count(); ++i) {
            newNode.__children.append(child := children[i]);
            child.setParent(newNode);
            newNode.node.size += children[i].getSize();
        }

        return newNode;
    }

    ## Append a new child to the end of the tree.  If the insertion of the
    ## child results in an intermediate node being split, return the new
    ## intermediate node.  Otherwise return null.
    ## 'child' must be a content node.
    CachedNode __appendChild(CachedNode child) {
        if (!__populateChildren(false)) {
            # Content node.  Just return the new child as the extra node,
            # parent will append.
            return child;
        } else if (!__children ||
                   __children[0].getNode().node.children is null) {
            # The children of this node are content nodes, append here.
            # (we do the check for !__children because it's possible to end up
            # in an intermediate state with no children.  grrrr... broken
            # invariants)
            __children.append(ent := __makeUnnamedEntry(child, this));
            node.size += ent.getSize();
            @assert(ent.getParent() is this);
            return __maybeSplit();
        } else {
            node.size += child.node.size;

            # Recurse to last child, update the size in the entry.
            lastChild := __children[-1];
            extra := lastChild.getNode().__appendChild(child);
            if (extra) {
                lastChild.fixSize();
                __children.append(ent := __makeUnnamedEntry(extra, this));
                @assert(ent.getParent() is this);
                return __maybeSplit();
            } else {
                # If we added to the last child without a split, we need to
                # update the entry's size.
                lastChild.entry.size += child.node.size;
            }
        }

        return null;
    }

    ## Reset the node object associated with the cached node and also reset
    ## all fields dependent on the node and mark the cached node as dirty.
    void __resetNode(Node node) {
        this.node = node;
        __children = null;
        digest = null;
        dirty = true;
    }

    Node __makeNode(String contents) {
        newNode := Node();
        newNode.contents = contents;
        newNode.size = contents.size;
        return newNode;
    }

    ## Steal and reparent the child array from 'other'.
    void __stealChildren(CachedNode other) {
        __children = other.__children;
        node.children = other.__children.getRep();
        for (child :in __children)
            child.setParent(this);
        other.__children = null;
    }

    ## Add a new tier to a top-level node by creating a new child node and
    ## moving all of the children to it.
    void __addTier() {
        @assert(__populateChildren(false));

        # Create a new node to hold the existing children.
        firstChild := CachedNode(__cache, null, node);
        firstChild.__stealChildren(this);

        # Create a new node with a child array.
        __resetNode(Node());
        __populateChildren(true);

        __children.append(ent := __makeUnnamedEntry(firstChild, this));
        node.size += ent.getSize();
        firstChild.parent = this;
    }

    ## Append a new content string to the end of the tree.
    ## XXX this code probably doesn't work with persistence.
    void append(String contents) {
        newNode := __makeNode(contents);
        cached := CachedNode(__cache, null, newNode);
        extra := __appendChild(cached);
        if (extra) {
            # If this is a content node, we need to convert it to an
            # intermediate node.
            if (node.children is null) {
                CachedNode firstChild;
                if (node.contents != null)
                    firstChild = CachedNode(__cache, null, node);

                # Create a new node with a child array.
                __resetNode(Node());
                __populateChildren(true);

                if (firstChild) {
                    __children.append(ent := __makeUnnamedEntry(firstChild,
                                                                this));
                    node.size += ent.getSize();
                }
            } else {
                # The current node is the top-level intermediate node and it
                # has been split.
                __addTier();
            }
            __children.append(ent := __makeUnnamedEntry(extra, this));
            node.size += ent.getSize();
            # XXX we need to "maybeSplit" after this and then do the same
            # switch we did above.
        }
    }

    ## Write the beginning of the chunk containing 'pos' up to 'pos'.
    ## Returns the
    uint64 __writeChunkPrefix(Writer out, uint64 pos) {

        # If we've got contents, write the beginning of the contents.
        if (node.contents) {
            out.write(Buffer(node.contents.buffer, uintz(pos)));
            return 0;
        }

        # Otherwise find the child containing the position.
        uint64 base;
        for (child :in __children) {
            if (pos < base + child.getSize()) {
                return base +
                       child.getNode().__writeChunkPrefix(out, pos - base);
            }

            base += child.getSize();
        }

        # We shouldn't get here, the position begins after all children.
        return base;
    }

    ## Write the end of the chunk containing pos (from pos to the end of the
    ## chunk).
    ## Returns the position of the end of the chunk.  If the return value is
    ## greater than the size of the chunk, the caller must also write the next
    ## child.
    uint64 __writeChunkSuffix(Writer out, uint64 pos) {
        # If the specified position is out of range, there's nothing to write.
        if (pos >= node.size)
            return node.size;

        if (node.contents) {
            out.write(Buffer(node.contents.buffer + pos,
                             node.contents.size - pos
                             )
                      );
            # If we're going to overwrite the chunking window, we need to
            # return a signal to write the next chunk.
            if (node.contents.size - pos < DEFAULT_WINDOW_SIZE) {
                return node.contents.size + 1;
            }
            return node.contents.size;
        }

        uint64 base, continueToNext;
        for (child :in __children) {
            childSize := child.getSize();
            if (pos < base + childSize) {
                end := child.getNode().__writeChunkSuffix(out, pos - base);
                if (end <= childSize)
                    return base + end;

                # The end exceeds the size of the child - continue to the next
                # child.
                pos = base + childSize;
                continueToNext = 1;
            }
            base += childSize;
        }

        # We can get here if 'pos' is greater than the child -- or if we need
        # to also add the next child because we may have changed the
        # fingerprint.
        return base + continueToNext;
    }

    ## Returns the children array, throwing an AssertionError if this is not
    ## an inner node.
    @final __ChildArray __getChildren() {
        @assert(__populateChildren(false));
        return __children;
    }

    ## Merge the child at the specified index with its nearest sibling.
    ## Returns true if we merged with the next child, false if we merged with
    ## the previous child.
    ##
    ## This is only public for tests.
    @final bool mergeChild(uint index) {
        bool mergeWithNext;
        node := __children[index].getNode();
        @assert(node.getChildCount() == 1);
        entry := node.__children[0];

        if (index == 0 ||
            index < __children.count() - 1 &&
             __children[index + 1].getNode().getChildCount() <
             __children[index - 1].getNode().getChildCount()
            ) {
            # Merge with the next child.

            nextChildEntry := __children[index + 1];
            nextChild := nextChildEntry.getNode();
            nextChild.__getChildren().insert(0, entry);
            nextChild.node.size += entry.getSize();
            nextChildEntry.fixSize();
            entry.setParent(nextChild);

            # Remove the child.
            __children.delete(index);

            # If the entry itself only has one child, merge recursively.
            if ((n := entry.getNode()).__populateChildren(false) &&
                 n.__getChildren().count() == 1
                )
                nextChild.mergeChild(0);

            # Split the new entry.
            newChild := nextChild.__maybeSplit();
            if (newChild) {
                nextChildEntry.fixSize();
                __children.insert(index + 1,
                                  __makeUnnamedEntry(newChild, this)
                                  );
            }

            return true;
        } else {
            # Merge with the previous child.

            prevChildEntry := __children[index - 1];
            prevChild := prevChildEntry.getNode();
            prevChild.__getChildren().append(entry);
            prevChild.node.size += entry.getSize();
            prevChildEntry.fixSize();
            entry.setParent(prevChild);

            # Remove the child.
            __children.delete(index);

            # If the entry itself only has one child, merge recursively.
            if ((n := entry.getNode()).__populateChildren(false) &&
                 n.__getChildren().count() == 1
                )
                prevChild.mergeChild(prevChild.__getChildren().count() - 1);

            # Split the new entry.
            newChild := prevChild.__maybeSplit();
            if (newChild) {
                prevChildEntry.fixSize();
                __children.insert(index,
                                  __makeUnnamedEntry(newChild, this)
                                  );
            }

            return false;
        }
    }

    ## Returns the size of the child deleted, returns the negative size if the
    ## child is an intermediate node with only one child of its own after the
    ## delete.
    int64 __deleteNode(uint64 pos) {
        @assert(__populateChildren(false));
        uint index;
        for (child :in __children) {
            int64 childSize;
            if (pos < child.getSize()) {
                # Delete this node or one of its children.
                if (child.getNode().isContentNode()) {
                    # The child is a content node.  Remove it.
                    childSize = int64(child.getSize());
                    __children.delete(index);
                } else {
                    # The child is an intermediate node, have it remove the
                    # appropriate content node.
                    childSize = child.getNode().__deleteNode(pos);
                    if (childSize < 0) {
                        # The child now has only one child of its own.
                        mergeChild(index);
                        childSize = -childSize;
                    }

                    child.entry.size -= uint64(childSize);
                }

                node.size -= uint64(childSize);
                return (__children.count() < 2) ? -childSize : childSize;
            }

            pos -= child.getSize();
            ++index;
        }

        # If we get here, the caller has specified a position that is out of
        # bounds.
        @assert(false);
        return 0;
    }

    ## Delete the leaf node at the position.  Call this on the top-level node
    ## of a file.
    ## Returns the size of the deleted node.
    int64 deleteNode(uint64 pos) {
        size := __deleteNode(pos);

        # If we have one child left, collapse the level.  We don't need to
        # call __populateChildren, __deleteNode() should have done that for us.
        if (__children.count() == 1) {
            cachedNode := __children[0].getNode();
            node = cachedNode.node;
            __stealChildren(cachedNode);
            if (parent) {
                entry := parent.__getChildEntry(this);
                entry.setCachedNode(this);
            }
        }

        __markDirty();
        return size;
    }

    ## Delete a span from the tree.  Returns true of the node now has a single
    ## child and should be merged.
    bool __deleteSpan(uint64 start, uint64 end) {
        if (node.contents) {
            if (start > node.contents.size) {
                return false;
            } else if (start < node.contents.size && end < node.contents.size) {
                node.contents = node.contents.substr(0, start) +
                                node.contents.substr(end);
            } else {
                # Delete everything after start.
                node.contents = node.contents.substr(0, start);
            }
            node.size = node.contents.size;
            dirty = true;
            return false;
        }

        # This is an inner node.
        @assert(__populateChildren(false));
        for (int i; i < __children.count() && end; ++i) {
            child := __children[i];
            childSize := child.getSize();

            if (start == 0 && end >= childSize) {
                # The entire child node must be deleted.
                __children.delete(i);
                node.size -= childSize;
                dirty = true;
                --i;
                end -= childSize;
            } else if (start < childSize) {
                # Part of the child must be deleted.
                mustMerge := child.getNode().__deleteSpan(start, end);
                child.fixSize();
                amtDeleted := childSize - child.getSize();
                node.size -= amtDeleted;
                dirty = true;
                spanSize := end - start;
                start = 0;

                adjustedSpan := false;

                # Before merging we have to verify that we have more than one
                # child because this algorithm can leave us with just one
                # remaining child.  We account for this in the merge - if
                # we're merging a child that has only one child we recursively
                # merge it.
                if (mustMerge && __children.count() > 1) {
                    if (mergeChild(i)) {
                        # We merged with the _next_ child, so we have to adjust
                        # the span.
                        start = child.getSize();
                        end = start + spanSize - amtDeleted;
                        adjustedSpan = true;
                    }
                    --i;
                }

                if (!adjustedSpan) {
                    # No merge or merged with previous.  Adjust the start and
                    # end for the next child.
                    start = 0;
                    if (end < childSize)
                        break;
                    else
                        end -= childSize
                }
            } else {
                start -= childSize;
                end -= childSize;
            }
        }

        return __children.count() == 1;
    }

    ## Delete a range of bytes from the file.  This should only be applied to
    ## the toplevel node of a file.
    void deleteSpan(uint64 start, uint64 end) {
        if (__deleteSpan(start, end)) {
            # We need to collapse a level.
            firstChild := __children[0].getNode();
            if (firstChild.node.contents) {
                # The child is a content node, steal its contents.
                node.contents = firstChild.node.contents;
                node.size = node.contents.size;
                __children = null;
                node.children = null;
            } else {
                __stealChildren(firstChild);
            }
        }

        __markDirty();
    }

    ## Delete all chunks between start and end.
    ## Returns true if the node now has only a single child (and thus the
    ## should be merged with a sibling).
    ## XXX doesn't work, removedSize can't be calculated given this signature.
    ## XXX THis is obsolete at this point, see __deleteSpan() instead.
    bool __deleteContentNodes(uint64 start, uint64 end) {
        if (node.contents)
            return false;

        uint64 base, removedSize;
        uint deleteStart = __children.count();
        uint i;
        for (child :in __children) {
            if (base >= end)
                # Passed the end of the range.
                break;

            if (base >= start) {
                # We're in range.

                # Mark the start index if we don't have one.
                if (i < deleteStart)
                    deleteStart = i;

                # Recurse on all children.
                removedSize +=
                    uint64(child.getNode().__deleteContentNodes(start - base,
                                                                end - base
                                                                ) ? 1 : 0
                           );

            }

            base += child.getSize();

            # We're want 'i' to be the index of the node after the last child
            # to be deleted, so we only update it if we're still in range and
            # the entire child node can be deleted.
            if (base < end)
                ++i;
        }

        # Delete all nodes in the range.
        count := i - deleteStart;
        while (count--)
            __children.delete(deleteStart);

        node.size -= removedSize;
        return removedSize;
    }

    CachedNode __insertChild(uint64 pos, CachedNode node) {
        # This only works on inner nodes.
        @assert(__populateChildren(false));
        @assert(pos <= this.node.size);
        int i;

        dirty = true;

        if (!__children) {
            # Deal with the case of an empty node. This can currently happen
            # only in the case where the entire contents of a toplevel node
            # are being replaced.  XXX I don't think this can happen in this
            # case, even.
            __children.append(__makeUnnamedEntry(node, this));
        } else if (__children[0].getNode().isContentNode()) {
            # The children are content nodes, directly insert.

            # Shortcut if we're inserting at the end.
            if (pos == this.node.size) {
                __children.append(__makeUnnamedEntry(node, this));
            } else {
                # Find the child to insert after.
                for (child :in __children) {
                    if (!pos) {
                        __children.insert(i, __makeUnnamedEntry(node, this));
                        break;
                    } else {
                        @assert(pos >= child.getSize());
                    }

                    pos -= child.getSize();
                    ++i;
                }
            }
        } else {
            # Inner node, recurse.

            # See if we're inserting at the end.
            if (pos == this.node.size) {
                child := __children[-1];
                extra := child.getNode().__insertChild(child.getSize(), node);
                child.fixSize();
                if (extra)
                    __children.append(__makeUnnamedEntry(extra, this));
            } else {
                int i = 1;
                for (child :in __children) {
                    if (pos < child.getSize()) {
                        extra := child.getNode().__insertChild(pos, node);
                        child.fixSize();
                        if (extra) {
                            __children.insert(i, __makeUnnamedEntry(extra, this));
                        }
                        break;
                    }

                    pos -= child.getSize();
                    ++i;
                }
            }
        }

        this.node.size += node.getSize();
        return __maybeSplit();
    }

    void __insert(uint64 pos, String contents) {
        newNode := CachedNode(__cache, null, __makeNode(contents));

        extra := __insertChild(pos, newNode);
        if (extra) {
            __addTier();
            __children.append(__makeUnnamedEntry(extra, this));
            node.size += extra.getSize();
        }
    }

    ## Write the last chunk to out, return the start position of the chunk.
    uint64 __writeLastChunk(Writer out) {
        if (isContentNode()) {
            out.write(node.contents);
            return 0;
        } else {
            @assert(__populateChildren(false));
            uint64 start;
            lastChild := __children[-1];
            offset := lastChild.getNode().__writeLastChunk(out);
            return offset + getSize() - lastChild.getSize();
        }
    }

    ## Write data to a file at 'pos'.
    ##
    ## This needs to be applied to the top node of the file.
    void __write(uint64 pos, Buffer data) {
        class ListWriter @impl Writer {
            StringArray items = {};

            void write(Buffer data) {
                items.append(String(data));
            }
        }

        ListWriter writer = {};
        RabinChunker chunker = {writer};

        if (node.children is null && !node.contents) {

            # Empty node.

            # We don't have to mix in with anything.
            chunker.writeZeros(pos - getSize());
            chunker.write(data);
            chunker.flush();

            # Just append all of the items to the tree.
            for (item :in writer.items)
                append(item);

        } else if (!(node.contents is null)) {

            # This is a node with contents.

            # Copy the existing contents until we get to 'pos'.
            if (pos) {
                if (pos > node.contents.size) {
                    chunker.write(node.contents);
                    chunker.writeZeros(pos - node.contents.size);
                } else {
                    chunker.write(node.contents.substr(0, pos));
                }
            }

            # Write the data.
            chunker.write(data);

            # If there's content after the data, write it.
            end := pos + data.size;
            if (end < node.contents.size)
                chunker.write(Buffer(node.contents.buffer + uintz(end),
                                     node.contents.size - end
                                     )
                              );

            chunker.flush();

            # Replace the existing contents with the new items.
            node.contents = null;
            for (item :in writer.items)
                append(item);

        # All remaining cases are nodes with children.

        } else if (pos >= getSize()) {
            # We're writing after the end, just append.

            # Start with the last chunk (we will likely need to extend it).
            start := __writeLastChunk(chunker);

            # Write the new data.
            chunker.writeZeros(pos - getSize());
            chunker.write(data);
            chunker.flush();

            # Remove the last chunk. Note:  This can break the "no empty inner
            # nodes" invariant in cases where a node has a single child (which
            # also breaks an invariant...)
            __deleteSpan(start, getSize());

            for (item :in writer.items)
                append(item);
        } else {
            # Write beginning in the middle of a node with children.

            # Write the beginning of the first existing chunk.
            start := __writeChunkPrefix(chunker, pos);

            # Write the data.
            chunker.write(data);

            # Find the node containing the end position (if any).
            end := __writeChunkSuffix(chunker, pos + data.size);

            # If we get an end position greater than the size, it just means
            # that we would have to write the next chunk.  Since there is no
            # next chunk, just adjust the size.
            if (end > getSize())
                end = getSize();

            chunker.flush();

            # Replace all of the chunks in the span.
            delta := end - start;  orgSize := getContents().size;
            __deleteSpan(start, end);
            @assert(getContents().size == orgSize - delta);
            pos = start;
            for (item :in writer.items) {
                __insert(pos, item);
                pos += item.size;
            }
        }

        __markDirty();
    }

    void write(uint64 pos, Buffer data) {
        __write(pos, data);

        change := Change();
        change.type = CHANGE_WRITE;
        @assert(pos < 0x100000000);
        change.pos = pos;
        change.data = String(data);
        __recordChange(change);
    }

    void __resize(uint64 newSize) {
        if (newSize == node.size)
            return;
        else if (newSize < node.size)
            deleteSpan(newSize, node.size);
        else
            __write(newSize, '');
    }

    ## Resize contents to the specified size.  Truncate the node if less than
    ## the existing size, pad with zeroes if greater than the existing size.
    ## Returns false if unable to accomodate.
    bool resize(uint64 newSize) {
        __resize(newSize);

        change := Change();
        change.type = CHANGE_RESIZE;
        change.newSize = newSize;
        __recordChange(change);

        return true;
    }

    ## Commit all outstanding changes in the tree.  Returns the new digest.
    String commit() {
        # If our digest is up to date, we don't need to do anything.
        if (!dirty)
            return digest;

        if (__populateChildren(false)) {
            # Commit all dirty children and reconstruct the child list for the
            # underlying node.
            for (child :in __children) {
                # XXX I think if 'child.node' is null we almost certainly do't
                # have to load it so we can commit it...  and we shouldn't be
                # invoking it without checking it.
                dig := child.node.commit();
                curDigest := child.getDigest();
                if (!curDigest || curDigest != dig)
                    child.setDigest(dig);
            }
        }

        # Commit the node itself and clear the journal.
        orgDigest := digest;
        if (__children) {
            for (child :in __children) {
                if (!child.entry.hash)
                    throw AssertionError(
                        FStr() `Invalid hash for $(child.getName())`
                    );
            }
        }

        digest = __cache.storeNode(node);
        dirty = false;
        __cache.clearJournal();

        return digest;
    }

    ## Utility class for formatting a Change message.  This is useful for
    ## debugging problems during journal replay.
    class ChangeFormatter {
        CachedNode node;
        Change change;
        oper init(CachedNode node, Change change) :
            node = node,
            change = change {
        }

        void formatChange(Formatter out) {
            if (change.type == CHANGE_ADD_CHILD) {
                out ` add child $(change.name)`;
            } else if (change.type == CHANGE_DELETE_CHILD) {
                out ` delete child $(change.name)`;
            } else if (change.type == CHANGE_WRITE) {
                out ` write\n`;
            } else if (change.type == CHANGE_RESIZE) {
                out ` resize to $(change.newSize)`;
            }
        }

        void formatTo(Formatter out, CachedNode n, int index) {
            if (change.path && index < change.path.count()) {
                n.__populateChildren(true);
                entry := n.__children[change.path[index]];
                out I`$(entry.entry.name)`;
                out `($(change.path[index]))/`;
                if (!entry.node && !entry.entry.hash) {
                    out `<NULL HASH>`;
                    formatChange(out);
                    return;
                }
                formatTo(out, entry.getNode(), ++index);
            } else {
                formatChange(out);
            }
        }

        void formatTo(Formatter out) {
            formatTo(out, node, 0);
        }
    }

    void __applyChange(Change change) {
        if (change.type == CHANGE_ADD_CHILD) {
            __addChild(change.name, CachedNode(__cache, null, change.node));
        } else if (change.type == CHANGE_DELETE_CHILD) {
            if (!__populateChildren(false) || !__children.delete(change.name))
                throw InvalidStateError(
                    FStr() `replaying delete: can't delete child $(change.name)`
                );
            __markDirty();
        } else if (change.type == CHANGE_WRITE) {
            __write(uint64(change.pos), change.data);
        } else if (change.type == CHANGE_RESIZE) {
            __resize(uint64(change.newSize));
        } else {
            error `Unrecognized change type $(change.type)`;
        }
    }

    ## Lookup a change in the descendent tree, return the descendant that the
    ## change applies to.
    CachedNode __lookup(Change change, int index) {
        if (!change || !change.path || index >= change.path.count())
            return this;

        # Get the child index from the path.
        childIndex := change.path[index];
        @assert(node.children && childIndex < node.children.count());
        __populateChildren(false);
        return __children[childIndex].getNode().__lookup(change, index + 1);
    }

    ## Replay all journal entries against the node.  If the node doesn't have
    ## a digest or there are no changes, does nothing.  Should only be used on
    ## the root node.
    void replayJournal() {
        if (parent)
            throw InvalidArgumentError('Replay journal only works against the '
                                        'root node.'
                                       );

        String lastChangeDigest;
        for (entry :in __cache.makeJournalIter()) {
            change := entry.change;
            if (!lastChangeDigest) {
                # First change after a commit.  Verify that the change has a
                # commit hash that matches the last commit.
                if (!change.commit)
                    throw InvalidStateError('First change in the journal '
                                             'does not have a commit field.'
                                            );
                if (change.commit != __cache.baselineCommit)
                    throw InvalidStateError(
                        FStr() I`First change in the journal is for commit \
                                 $(altEncode(change.commit)), current commit \
                                 is $(altEncode(__cache.baselineCommit))`
                    );
            } else if (lastChangeDigest != change.lastChange) {
                throw InvalidStateError(
                    FStr() I`Change $(altEncode(entry.digest)) should be \
                             applied to $(altEncode(change.lastChange)). \
                             last change was $(altEncode(lastChangeDigest)).`
                );
            }
            node := __lookup(change, 0);
            @assert(node);
            node.__applyChange(change);
            lastChangeDigest = entry.digest;
        }

        # Give this to the cache.
        __cache.lastChange = lastChangeDigest;
    }

    uint read(uint64 pos, WriteBuffer buffer) {
        if (pos > node.size)
            return 0;

        buffer.size = 0;
        if (node.contents) {

            # We've got contents, read from there.
            if (pos < node.contents.size) {
                uint size;
                if (buffer.cap >= node.contents.size - pos)
                    size = node.contents.size - pos;
                else
                    size = buffer.cap;
                buffer.move(0, node.contents.buffer + pos,
                            size
                            );
                buffer.size = size;
            } else {
                buffer.size = 0;
            }
        } else if (node.children) {

            WriteBuffer frame = {null, 0, 0};
            @assert(__populateChildren(false));
            for (child :in __children) {
                if (pos < child.getSize()) {

                    # Delegate the operation to the child

                    # Make the frame buffer the remaining part of the input
                    # buffer.
                    frame.buffer = buffer.buffer + buffer.size;
                    frame.cap = buffer.cap - buffer.size;
                    frame.size = 0;

                    # Pass this off to the child.
                    amtRead := child.getNode().read(pos, frame);
                    buffer.size += amtRead;

                    # Quit if we've filled the buffer.
                    if (buffer.size == buffer.cap)
                        break;

                    # Reset pos to zero so we start at the beginning of the
                    # next child.
                    pos = 0;
                } else {
                    # Fix the position to be relative to the start of the next
                    # child.
                    pos -= child.getSize();
                }
            }
        }

        return buffer.size;
    }

    @struct VerifyReport {
        uint64 size;
        uint depth;
    }

    VerifyReport verify() {

        # If the node isn't dirty, verify that we have a correct digest.
        if (!dirty) {
            @assert(digest);
            @assert(digest == __cache.store.makeDigest(node));
        }

        if (node.contents) {
            @assert(node.contents.size == node.size);
            @assert(node.contents.size <= __cache.maxContentSize);
            return VerifyReport(node.contents.size, 1);
        } else if (node.children) {
            @assert(__populateChildren(false));
            @assert(node.children.count() == __children.count());
            uint64 totalSize;
            uint depth = 0;
            for (child :in __children) {
                childReport := child.getNode().verify();
                @assert(child.getSize() == childReport.size);
                @assert(child.getParent() is this);
                @assert(child.getNode().parent is this);
                totalSize += childReport.size;
                if (depth) {
                    @assert(depth == childReport.depth);
                } else {
                    depth = childReport.depth;
                }
            }
            @assert(node.size == totalSize);

            return VerifyReport(totalSize, depth + 1);
        } else {
            return VerifyReport(0, 1);
        }
    }

    void formatTo(Formatter out) {
        indent := Indenter.wrap(out);
        indent `CachedNode {\n`;
        __populateChildren(false);
        ++indent;
        int min(int a, int b) { return (a < b) ? a : b }
        indent I`hash: $(digest ? altEncode(digest) : 'null')
                 size: $(node.size)
                 contents: $(!(node.contents is null) ?
                                node.contents.substr(0, min(node.contents.size,
                                                         10)).getRepr() :
                                'null'
                             )
                 entries: $__children\n`;
        --indent;
        indent `}`;
    }
}

CachedNode _makeCachedNode(CachedNode parent, Cache cache, String digest) {
    node := cache.getNode(digest);
    if (!node)
        return null;

    result := CachedNode(cache, digest, node);
    result.parent = parent;
    return result;
}
