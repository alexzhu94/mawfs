# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## The node cache.
module;

import crack.enc.base64 altEncode;
import crack.cont.hashmap HashMap;
import crack.io.fmtutil Indenter;
import crack.io Formatter, FStr, Writer;
import crack.cont.array Array;
import crack.lang cmp, AppendBuffer, AssertionError, Buffer, Exception,
    InvalidArgumentError, InvalidStateError, KeyError, ManagedBuffer,
    WriteBuffer, makeHashVal;
import crack.logger debug, error;
import crack.strutil StringArray;
import mawfs.blockstore Entry, Change, JournalIter, Node, NodeStore, MODE_DIR;
import mawfs.chunker RabinChunker;

@import crack.ann assert, impl;

# Allow initial blocks of up to one meg.
const DEFAULT_MAX_CONTENT_SIZE := 1024 * 1024;
const DEFAULT_MAX_CHILDREN := 256;

const int32
    ## Add child (contains a Node and a name)
    CHANGE_ADD_CHILD = 1,

    ## Delete a child (contains a name).
    CHANGE_DELETE_CHILD = 2,

    ## Write data to node contents (respecting all current rules about file
    ## size, layout etc).  Contains pos and data.
    CHANGE_WRITE = 3,

    ## Resize node contents.  Contains newSize.
    CHANGE_RESIZE = 4;

class Cache {
    NodeStore store;

    String baselineCommit;
    String lastChange;
    String branch;

    uint maxContentSize = DEFAULT_MAX_CONTENT_SIZE;
    uint maxChildren = DEFAULT_MAX_CHILDREN;

    oper init(NodeStore store, String branch, String baselineCommit) :
        store = store,
        branch = branch,
        baselineCommit = baselineCommit {
    }

    @final void addChange(Change change) {
        if (lastChange) {
            change.lastChange = lastChange;
        } else {
            change.commit = baselineCommit;
        }
        lastChange = store.writeToJournal(branch, change);
    }

    @final String storeNode(Node node) {
        return store.storeNode(node);
    }

    @final Node getNode(String digest) {
        return store.getNode(digest);
    }

    @final void clearJournal() {
        store.deleteJournal(branch);
    }

    @final JournalIter makeJournalIter() {
        return store.makeJournalIter(branch);
    }

    ## Records the digest of a new commit.
    @final void recordCommit(String commit) {
        lastChange = null;
        baselineCommit = commit;
    }
}

class CachedNode;

## Creates a CachedNode.
CachedNode _makeCachedNode(CachedNode parent, Cache cache, String digest);

## Wraps a Node object with caching functionality.
class CachedNode {
    Cache __cache;

    String digest;
    Node node;

    ## Indicates that a node has been changed in memory and in the transaction
    ## log but needs to be committed.  A dirty node is assumed to have an
    ## invalid digest.  Likewise, a non-dirty node is assumed to have a valid
    ## digest.  All nodes should either be loaded from the block store (in
    ## which case, they have a valid digest) or created as part of an
    ## operation (in which case they should have no digest and be dirty).
    bool dirty;

    ## The parent node (the directory that this node is in).
    CachedNode parent;

    uint64 verify();

    ## Gets the node's mode.
    @final int getMode() {
        return node.mode;
    }

    @final bool isDir() {
        return node.mode & MODE_DIR;
    }

    @final uint64 getSize();

    class CachedEntry {
        Entry entry;
        Cache __cache;
        CachedNode node;
        CachedNode __parent;

        oper init(Cache cache, Entry entry, CachedNode parent) :
            entry = entry,
            __cache = cache,
            __parent = parent {
        }

        oper init(Entry entry, CachedNode node, CachedNode parent) :
            entry = entry,
            node = node,
            __parent = parent {

            # We shouldn't really need the cache if we've already got the
            # node, but this gives us a clean invariant.
            __cache = node.__cache;
        }

        @final String getName() {
            return entry.name;
        }

        @final String getDigest() {
            return entry.hash;
        }

        @final void setDigest(String digest) {
            entry.hash = digest;
        }

        @final uint64 getSize() {
            return uint64(entry.size);
        }

        ## Returns the node referenced by this child object.
        @final CachedNode getNode() {
            # Lazy load the node.
            if (!node) {
                if (!entry.hash)
                    throw InvalidStateError(
                        FStr() `No hash or node for $(entry.name)`
                    );
                node = _makeCachedNode(__parent, __cache, entry.hash);
            }
            return node;
        }

        @final int getMode() {
            return getNode().getMode();
        }

        @final CachedNode getParent() { return __parent }
        @final void setParent(CachedNode parent) {
            __parent = parent;
            if (node)
                node.parent = parent;
        }

        @final void setCachedNode(CachedNode node) {
            this.node = node;
            entry.size = node.getSize();
            entry.hash = null;
        }
    }

    ## A list of children sorted by name.  Retrieval/insertion by name is
    ## supported.
    ## node.children must exist for this to be created.
    class __ChildArray {

        # Underlying representation (stored in the Node).
        Array[Entry] __rep;

        # Cached entries.
        Array[CachedEntry] __cached;

        oper init(Array[Entry] rep) :
            __rep = rep,
            __cached(rep.count(), null) {
        }

        ## Recursive helper for __findIndex(String).
        @final int __findIndex(String name, uint start, uint end) {

            if (!__cached.count())
                return -1;

            uint midpoint = (end - start) / 2 + start;
            if (midpoint == start) {
                comparison := cmp(name, __cached[midpoint].getName());
                if (comparison == 0)
                    return start;
                else if (comparison < 0)
                    return -(start + 1);
                else
                    return -(end + 1);
            }

            if (name == __cached[midpoint].getName())
                return midpoint;

            if (name < __cached[midpoint].getName())
                return __findIndex(name, start, midpoint);
            else
                return __findIndex(name, midpoint, end);
        }

        ## Find the index of the child with the given name.  If there is no
        ## match in the array, returns the
        ## negative index + 1 of where the element would be (so if it belonged
        ## at index 0, we would return -1).  Returns the index of the element
        ## if it was found as an ordinary positive integer.
        @final int findIndex(String name) {
            return __findIndex(name, 0, __cached.count());
        }

        ## Return the entry identified by the name, null if it doesn't exist.
        @final CachedEntry get(String name) {
            i := __findIndex(name, 0, __cached.count());
            if (i < 0)
                return null;
            else
                return __cached[i];
        }

        ## Adds a child to the array by order of name.
        @final void add(CachedEntry entry) {
            i := findIndex(entry.getName());
            if (i >= 0) {
                __cached[i] = entry;
                __rep[i] = entry.entry;
            } else {
                __cached.insert(-i - 1, entry);
                __rep.insert(-i - 1, entry.entry);
            }
        }

        @final bool delete(String name) {
            i := findIndex(name);
            if (i >= 0) {
                __cached.delete(i);
                __rep.delete(i);
                return true;
            } else {
                return false;
            }
        }

        ## Deletes a child by index.
        @final void delete(uint index) {
            __cached.delete(index);
            __rep.delete(index);
        }

        @final void append(CachedEntry entry) {
            __cached.append(entry);
            __rep.append(entry.entry);
        }

        @final void insert(uint index, CachedEntry entry) {
            __cached.insert(index, entry);
            __rep.insert(index, entry.entry);
        }

        @final uint count() {
            return __cached.count();
        }

        @final CachedEntry oper [](int index) {
            return __cached[index];
        }

        @final CachedEntry oper []=(int index, CachedEntry entry) {
            return __cached[index] = entry;
        }

        @final Array[CachedEntry].ArrayIter iter() { return __cached.iter() }

        void formatTo(Formatter out) {
            indent := Indenter.wrap(out);
            out `CachedEntries![\n`;
            for (child :in __cached) {
                dig := child.getDigest();
                String digest;
                if (dig)
                    digest := altEncode(dig);
                name := child.getName();
                if (name is null)
                    out `-   `;
                else
                    out I`$(name.getRepr()):\n`;
                ++indent;
                out I`digest: $(digest ? altEncode(digest) : 'null')
                      size: $(child.getSize())
                      node: `;
                out `$(child.node)\n`;
                --indent;
            }
            out `]`;
        }
    }

    # A sparse-array version of Node.children.  These get filled in as they
    # are accessed or when __populateChildren() is called.
    __ChildArray __children;

    ## digest should be null for a new node.
    oper init(Cache cache, String digest, Node node) :
        __cache = cache,
        digest = digest,
        node = node,
        dirty = !digest {
    }

    ## Allocate __children array to mirror the values in node.children.
    ## Creates node.children if it doesn't exist.
    @final void __makeChildren() {
        # First make sure we have node.children.
        if (!node.children)
            node.children = Array[Entry]();

        # Create an array of children to mirror that of node.children,
        # initialize all elements to null.
        __children = __ChildArray(node.children);
    }

    ## Allocate the __children scaffold and populate with the child entries
    ## from the node.
    ## If createEmpty is true, create the scaffold even if node.children is
    ## null, and also create an empty node.children.
    ## If createEmpty is false and children is null or empty, do nothing and
    ## return false.
    ## Return true if the scaffold exists at the end of the method, false if
    ## not.
    @final bool __populateChildren(bool createEmpty) {
        if (!(__children is null))
            return true;
        if (node.children || createEmpty) {
            if (node.children is null)
                node.children = Array[Entry]();
            __makeChildren();
            for (iter :on node.children)
                __children[iter.index] =
                    CachedEntry(__cache, iter.elem(), this);
            return true;
        } else {
            return false;
        }
    }

    CachedEntry __getChildEntry(uint index) {
        CachedEntry cachedEntry;
        if (!__populateChildren(false))
            return null;

        cachedEntry = __children[index];
        if (!cachedEntry) {
            entry := node.children[index];

            node := _makeCachedNode(this, __cache, entry.hash);
            if (!node) {
                error `Unable to load node $(entry.hash)`;
                return null;
            }

            cachedEntry = __children[index] = CachedEntry(entry, node, this);
        }

        return cachedEntry;
    }

    ## Get a child by its index.  Throw IndexError if the index is out of
    ## range.  Return null if we are unable to retrieve the node.
    CachedNode getChild(uint index) {
        cachedEntry := __getChildEntry(index);
        return cachedEntry.getNode();
    }

    ## Returns the name of a child.
    String getChildName(uint index) {
        cachedEntry := __getChildEntry(index);
        return cachedEntry.getName();
    }

    ## Get the child with the given name.  Returns null if there is no such
    ## child.
    @final CachedNode getChild(String name) {
        if (!__populateChildren(false))
            return null;
        child := __children.get(name);
        if (!child)
            return null;
        else
            return child.getNode();
    }


    ## Returns the total size of the node.
    @final uint64 getSize() {
        # TODO: Store this information in the node as well as its children.
        if (!(node.contents is null)) {
            return node.contents.size;
        } else if (node.children) {
            uint64 sum;
            for (child :in node.children)
                sum += uint64(child.size);
            return sum;
        } else {
            return 0;
        }
    }

    @final String getContents() {
        if (!(node.contents is null)) {
            return node.contents;
        } else if (node.children != null) {
            AppendBuffer buf = {getSize()};
            __populateChildren(false);
            for (child :in __children)
                buf.extend(child.getNode().getContents());
            return String(buf, true);
        } else {
            return null;
        }

    }

    ## Returns true if this is a content node (a leaf).
    @final bool isContentNode() { return node.contents }

    ## Returns the CachedEntry for the child wrapping the node.  Returns
    ## 'null' if undefined.
    @final CachedEntry __getChildEntry(CachedNode node) {
        for (child :in __children) {
            if (child.node is node)
                return child;
        }

        return null;
    }

    ## Mark the node as diry and do the same for all parent nodes.
    void __markDirty() {

        # Find the child in the parent and invalidate all instances.
        if (parent) {
            myEntry := parent.__getChildEntry(this);
            myEntry.setDigest(null);
        }

        dirty = true;
        if (parent) parent.__markDirty();
    }

    void __makePath(Array[int32] path) {
        if (!parent)
            return;

        # Lookup the index of the child (it is always safe to assume
        # __children has been populated for a parent).
        uint i = 0;
        for (child :in parent.__children) {

            # We use .node here instead of getNode(), if the node hasn't been
            # lazy loaded it can't be this one, and we don't want to lazy load
            # any new nodes.
            if (child.node is this)
                break;
            ++i;
        }

        parent.__makePath(path);
        path.append(int32(i));
    }

    ## Record a change in the journal for this node or for the appropriate
    ## parent node if this node doesn't have a digest yet.
    void __recordChange(Change change) {
        change.path = Array[int32]();
        __makePath(change.path);
        __cache.addChange(change);
    }

    ## Internal add child method, which does everything but create a change
    ## record.
    CachedNode __addChild(String name, Node node) {
        child := CachedNode(__cache, null, node);
        child.parent = this;

        CachedEntry entry = {Entry(), child, this};
        entry.entry.name = name;

        __populateChildren(true);

        # Add the child.
        __children.add(entry);

        # Mark the node and the entire ancestor chain as dirty.
        __markDirty();

        return child;
    }

    ## Add a new child node with the specified name.
    CachedNode addChild(String name, Node node) {
        child := __addChild(name, node);

        # Record the change in the journal.
        change := Change();
        change.type = CHANGE_ADD_CHILD;
        change.name = name;
        change.node = node;
        __recordChange(change);

        return child;
    }

    ## Delete the named child and return true, or return false if the child
    ## doesn't exist.
    bool deleteChild(String name) {
        if (!__populateChildren(true))
            return false;
        if (!__children.delete(name))
            return false;

        # Record the change.
        change := Change();
        change.type = CHANGE_DELETE_CHILD;
        change.name = name;
        __recordChange(change);
        __markDirty();

        return true;
    }

    ## Returns the number of children in the node.
    uint getChildCount() {
        return node.children ? node.children.count() : 0;
    }

    ## Returns the root of the cached filesystem.
    CachedNode getRoot() {
        if (!parent)
            return this;
        else
            return parent.getRoot();
    }

    ## Returns the cache object for the node.
    Cache getCache() {
        return __cache;
    }

    ## Make a new unnamed entry for the node parented by 'this'.
    CachedEntry __makeUnnamedEntry(CachedNode node, CachedNode parent) {
        entry := Entry();
        entry.size = node.getSize();
        cachedEntry := CachedEntry(__cache, entry, this);
        cachedEntry.node = node;
        cachedEntry.setParent(parent);
        return cachedEntry;
    }

    ## Split the node if it exceeds the maximum number of children.  If the
    ## node is split, return the new node full of the higher children.
    ## Otherwise return null.
    CachedNode __maybeSplit() {
        if (__children.count() <= __cache.maxChildren)
            return null;

        # Number of nodes in the new first child.
        newSize := __cache.maxChildren;

        # Make a copy of the children and reset.
        children := __children;
        __children = null;
        node.children = null;
        node.size = 0;
        __populateChildren(true);

        # Copy the lower children to the receiver.
        int i;
        for (; i < newSize; ++i) {
            __children.append(children[i]);
            node.size += children[i].getSize();
        }

        # Create a new node and copy the higher children.
        CachedNode newNode = {__cache, null, Node()};
        newNode.__populateChildren(true);
        for (; i < children.count(); ++i) {
            newNode.__children.append(child := children[i]);
            child.setParent(newNode);
            newNode.node.size += children[i].getSize();
        }

        return newNode;
    }

    ## Append a new child to the end of the tree.  If the insertion of the
    ## child results in an intermediate node being split, return the new
    ## intermediate node.  Otherwise return null.
    ## 'child' must be a content node.
    CachedNode __appendChild(CachedNode child) {
        if (!__populateChildren(false)) {
            # Content node.  Just return the new child as the extra node,
            # parent will append.
            return child;
        } else if (__children[0].getNode().node.children is null) {
            # The children of this node are content nodes, append here.
            __children.append(ent := __makeUnnamedEntry(child, this));
            node.size += ent.getSize();
            @assert(ent.getParent() is this);
            return __maybeSplit();
        } else {
            node.size += child.node.size;

            # Recurse to last child, update the size in the entry.
            lastChild := __children[-1];
            extra := lastChild.getNode().__appendChild(child);
            if (extra) {
                __children.append(ent := __makeUnnamedEntry(extra, this));
                @assert(ent.getParent() is this);
                return __maybeSplit();
            } else {
                # If we added to the last child without a split, we need to
                # update the entry's size.
                lastChild.entry.size += child.node.size;
            }
        }

        return null;
    }

    ## Reset the node object associated with the cached node and also reset
    ## all fields dependent on the node and mark the cached node as dirty.
    void __resetNode(Node node) {
        this.node = node;
        __children = null;
        digest = null;
        dirty = true;
    }

    Node __makeNode(String contents) {
        newNode := Node();
        newNode.contents = contents;
        newNode.size = contents.size;
        return newNode;
    }

    ## Steal and reparent the child array from 'other'.
    void __stealChildren(CachedNode other) {
        __children = other.__children;
        for (child :in __children)
            child.setParent(this);
        other.__children = null;
    }

    ## Add a new tier to a top-level node by creating a new child node and
    ## moving all of the children to it.
    void __addTier() {
        @assert(__populateChildren(false));

        # Create a new node to hold the existing children.
        firstChild := CachedNode(__cache, null, node);
        firstChild.__stealChildren(this);

        # Create a new node with a child array.
        __resetNode(Node());
        __populateChildren(true);

        __children.append(ent := __makeUnnamedEntry(firstChild, this));
        node.size += ent.getSize();
        firstChild.parent = this;
    }

    ## Append a new content string to the end of the tree.
    ## XXX this code probably doesn't work with persistence.
    void append(String contents) {
        newNode := __makeNode(contents);
        cached := CachedNode(__cache, null, newNode);
        extra := __appendChild(cached);
        if (extra) {
            # If this is a content node, we need to convert it to an
            # intermediate node.
            if (node.children is null) {
                CachedNode firstChild;
                if (node.contents != null)
                    firstChild = CachedNode(__cache, null, node);

                # Create a new node with a child array.
                __resetNode(Node());
                __populateChildren(true);

                if (firstChild) {
                    __children.append(ent := __makeUnnamedEntry(firstChild,
                                                                this));
                    node.size += ent.getSize();
                }
            } else {
                # The current node is the top-level intermediate node and it
                # has been split.
                __addTier();
            }
            __children.append(ent := __makeUnnamedEntry(extra, this));
            node.size += ent.getSize();
            # XXX we need to "maybeSplit" after this and then do the same
            # switch we did above.
        }
    }

    ## Write the beginning of the chunk containing 'pos' up to 'pos'.
    ## Returns the
    uint64 __writeChunkPrefix(Writer out, uint64 pos) {

        # If we've got contents, write the beginning of the contents.
        if (node.contents) {
            out.write(Buffer(node.contents.buffer,
                             node.contents.size - uintz(pos)
                             )
                      );
            return 0;
        }

        # Otherwise find the child containing the position.
        uint64 base;
        for (child :in __children) {
            if (pos < base + child.getSize()) {
                return base + child.getNode().__writeChunkPrefix(out, pos);
            }

            base += child.getSize();
        }

        # We shouldn't get here, the position begins after all children.
        return base;
    }

    ## Write the end of the chunk containing pos (from pos to the end of the
    ## chunk).
    ## Returns the position of the end of the chunk.
    uint64 __writeChunkSuffix(Writer out, uint64 pos) {
        if (node.contents) {
            out.write(Buffer(node.contents.buffer + pos,
                             node.contents.size - pos
                             )
                      );
            return node.contents.size;
        }

        uint64 base;
        for (child :in __children) {
            if (pos < base + child.getSize())
                return base +
                       child.getNode().__writeChunkSuffix(out, pos - base);
            base += child.getSize();
        }

        # Once again, shouldn't end up here.
        return base;
    }

    ## Merge the child at the specified index with its nearest sibling.
    ##
    ## This is only public for tests.
    @final void mergeChild(uint index) {
        bool mergeWithNext;
        node := __children[index].getNode();
        @assert(node.getChildCount() == 1);
        entry := node.__children[0];

        if (index == 0 ||
            index < __children.count() - 1 &&
             __children[index + 1].getNode().getChildCount() <
             __children[index - 1].getNode().getChildCount()
            ) {
            # Merge with the next child.

            nextChildEntry := __children[index + 1];
            nextChild := nextChildEntry.getNode();
            nextChild.__children.insert(0, entry);
            nextChildEntry.entry.size = nextChild.node.size += entry.getSize();
            entry.setParent(nextChild);

            # Remove the child.
            __children.delete(index);

            # Split the new entry.
            newChild := nextChild.__maybeSplit();
            if (newChild)
                __children.insert(index + 1,
                                  __makeUnnamedEntry(newChild, this)
                                  );
        } else {
            # Merge with the previous child.

            prevChildEntry := __children[index - 1];
            prevChild := prevChildEntry.getNode();
            prevChild.__children.append(entry);
            prevChild.node.size += entry.getSize();
            prevChildEntry.entry.size = prevChild.node.size += entry.getSize();
            entry.setParent(prevChild);

            # Remove the child.
            __children.delete(index);

            # Split the new entry.
            newChild := prevChild.__maybeSplit();
            if (newChild)
                __children.insert(index,
                                  __makeUnnamedEntry(newChild, this)
                                  );
        }
    }

    ## Returns the size of the child deleted, returns the negative size if the
    ## child is an intermediate node with only one child of its own after the
    ## delete.
    int64 __deleteNode(uint64 pos) {
        @assert(__populateChildren(false));
        uint index;
        for (child :in __children) {
            int64 childSize;
            if (pos < child.getSize()) {
                # Delete this node or one of its children.
                if (child.getNode().isContentNode()) {
                    # The child is a content node.  Remove it.
                    childSize = int64(child.getSize());
                    __children.delete(index);
                } else {
                    # The child is an intermediate node, have it remove the
                    # appropriate content node.
                    childSize = child.getNode().__deleteNode(pos);
                    if (childSize < 0) {
                        # The child now has only one child of its own.
                        mergeChild(index);
                        childSize = -childSize;
                    }

                    child.entry.size -= uint64(childSize);
                }

                node.size -= uint64(childSize);
                return (__children.count() < 2) ? -childSize : childSize;
            }

            pos -= child.getSize();
            ++index;
        }

        # If we get here, the caller has specified a position that is out of
        # bounds.
        @assert(false);
        return 0;
    }

    ## Delete the leaf node at the position.  Call this on the top-level node
    ## of a file.
    ## Returns the size of the deleted node.
    int64 deleteNode(uint64 pos) {
        size := __deleteNode(pos);

        # If we have one child left, collapse the level.  We don't need to
        # call __populateChildren, __deleteNode() should have done that for us.
        if (__children.count() == 1) {
            cachedNode := __children[0].getNode();
            node = cachedNode.node;
            __stealChildren(cachedNode);
            if (parent) {
                entry := parent.__getChildEntry(this);
                entry.setCachedNode(this);
            }
        }

        __markDirty();
        return size;
    }

    ## Delete all chunks between start and end.
    ## Returns true if the node now has only a single child (and thus the
    ## should be merged with a sibling).
    ## XXX doesn't work, removedSize can't be calculated given this signature.
    bool __deleteContentNodes(uint64 start, uint64 end) {
        if (node.contents)
            return false;

        uint64 base, removedSize;
        uint deleteStart = __children.count();
        uint i;
        for (child :in __children) {
            if (base >= end)
                # Passed the end of the range.
                break;

            if (base >= start) {
                # We're in range.

                # Mark the start index if we don't have one.
                if (i < deleteStart)
                    deleteStart = i;

                # Recurse on all children.
                removedSize +=
                    uint64(child.getNode().__deleteContentNodes(start - base,
                                                                end - base
                                                                ) ? 1 : 0
                           );

            }

            base += child.getSize();

            # We're want 'i' to be the index of the node after the last child
            # to be deleted, so we only update it if we're still in range and
            # the entire child node can be deleted.
            if (base < end)
                ++i;
        }

        # Delete all nodes in the range.
        count := i - deleteStart;
        while (count--)
            __children.delete(deleteStart);

        node.size -= removedSize;
        return removedSize;
    }

    CachedNode __insertChild(uint64 pos, CachedNode node) {
        # This only works on a node with children.
        @assert(__populateChildren(false));
        int i;

        dirty = true;

        # If the children are content nodes, directly insert.
        if (__children[0].getNode().isContentNode()) {
            for (child :in __children) {
                if (!pos) {
                    __children.insert(i, __makeUnnamedEntry(node, this));
                    break;
                } else {
                    @assert(pos >= child.getSize());
                }

                pos -= child.getSize();
            }
        } else {
            # Inner node, recurse.
            int i = 1;
            for (child :in __children) {
                if (pos < child.getSize()) {
                    extra := child.getNode().__insertChild(pos, node);
                    if (extra) {
                        __children.insert(i, __makeUnnamedEntry(extra, this));
                    }
                    break;
                }

                pos -= child.getSize();
                ++i;
            }
        }

        this.node.size += node.getSize();
        return __maybeSplit();
    }

    void __insert(uint64 pos, String contents) {
        newNode := CachedNode(__cache, null, __makeNode(contents));
        extra := __insertChild(pos, newNode);
        if (extra) {
            __addTier();
            __children.append(__makeUnnamedEntry(extra, this));
        }
    }

#    class __NodeBlock {
#        Array[CachedNode] nodes = {};
#        uint64 start, size;
#    }
#
#    ## Returns the lower tier (nodes near the leafs) for the range of
#    ## positions.  Having this allows us to replace all of the contents in
#    ## this tier with a simple linear sweep.
#    void __getLowerTier(__NodeBlock tier, uint64 start, uint64 end) {
#        if (__children && (child := __children[0].getNode()).node.contents) {
#            tier.nodes.append(this);
#            tier.childSize
#            return 0;
#        } else if (__children) {
#            uint64 childStart;
#            uint64 childEnd;
#            bool recordedStart;
#            for (child :in __children) {
#                childEnd += child.getSize();
#                if (start < childEnd && end > childStart) {
#                    child.getNode().__getLowerTier(tier, start - childStart,
#                                                   end - childStart
#                                                   );
#
#                    if (!recordedStart) {
#                        tier.start = childStart + tier.start;
#                        recordedStart = true;
#                    }
#                }
#                childStart += child.getSize();
#                if (childStart > end)
#                    break;
#            }
#        }
#    }

    ## Write data to a file at 'pos'.
    ##
    ## This needs to be applied to the top node of the file.
    void __write(uint64 pos, Buffer data) {
        class ListWriter @impl Writer {
            StringArray items = {};

            void write(Buffer data) {
                items.append(String(data));
            }
        }

        ListWriter writer = {};
        RabinChunker chunker = {writer};

        if (node.children is null && !node.contents ||
             pos == node.size
            ) {

            # Empty node.

            # We don't have to mix in with anything.
            chunker.writeZeros(pos);
            chunker.write(data);
            chunker.flush();

            # Just append all of the items to the tree.
            for (item :in writer.items)
                append(item);

        } else if (!(node.contents is null)) {

            # This is a node with contents.

            # Copy the existing contents until we get to 'pos'.
            if (pos) {
                chunker.write(node.contents.substr(0, pos));

                # Write zeroes if there's any extra space.
                if (pos > node.contents.size)
                    chunker.writeZeros(pos - node.contents.size);
            }

            # Write the data.
            chunker.write(data);

            # If there's content after the data, write it.
            end := pos + data.size;
            if (end < node.contents.size)
                chunker.write(Buffer(node.contents.buffer + uintz(end),
                                     node.contents.size - end
                                     )
                              );

            chunker.flush();

            # Replace the existing contents with the new items.
            node.contents = null;
            for (item :in writer.items)
                append(item);

        # All remaining cases are nodes with children.

        } else if (pos >= getSize()) {
            # We're writing after the end, just append.

            chunker.writeZeros(pos - getSize());
            chunker.write(data);
            chunker.flush();

            for (item :in writer.items)
                append(item);
        } else {
            # Write beginning in the middle of a node with children.

            # Write the beginning of the first existing chunk.
            start := __writeChunkPrefix(chunker, pos);

            # Write the data.
            chunker.write(data);

            # Find the node containing the end position (if any) and the node
            # after that.
            end := __writeChunkSuffix(chunker,
                                      pos + data.size + chunker.getWindowSize()
                                      );

            chunker.flush();

            # Replace all of the chunks in the span.
            # XXX  this isn't going to work quite right in all cases because
            # it doesn't reproduce the depth of the tree.
            __deleteContentNodes(start, end);
            for (item :in writer.items) {
                __insert(pos, item);
                pos += item.size;
            }
        }

        __markDirty();
    }

    void write(uint64 pos, Buffer data) {
        __write(pos, data);

        change := Change();
        change.type = CHANGE_WRITE;
        @assert(pos < 0x100000000);
        change.pos = pos;
        change.data = String(data);
        __recordChange(change);
    }

    void __resize(uint64 newSize) {
        if (node.contents is null) {
            # If the new size is zero, we don't have to do anything.
            # Otherwise, create a new empty contents buffer.
            if (newSize) {
                ManagedBuffer buf = {newSize};
                for (uint64 i = 0; i < newSize; ++i)
                    buf.buffer[i] = 0;
                buf.size = uintz(newSize);
                node.contents = String(buf, true);
            }
        } else if (node.contents.size > newSize) {
            node.contents = node.contents.substr(0, newSize);
        } else {
            # Create a new buffer and move the existing contents to it.
            AppendBuffer buf = {newSize};
            buf.move(0, node.contents);

            # Clear the rest of the buffer.
            for (uint64 i = buf.size; i < newSize; ++i)
                buf.buffer[i] = 0;
            buf.size = newSize;

            # Use it for contents.
            node.contents = String(buf, true);
        }

        __markDirty();
    }

    ## Resize contents to the specified size.  Truncate the node if less than
    ## the existing size, pad with zeroes if greater than the existing size.
    ## Returns false if unable to accomodate.
    bool resize(uint64 newSize) {
        # TODO: rewrite to use chunking.
        if (node.children is null) {
            __resize(newSize);

            change := Change();
            change.type = CHANGE_RESIZE;
            change.newSize = newSize;
            __recordChange(change);

            return true;
        } else {
            error `Can only do resize on content nodes at this time`;
            return false;
        }
    }

    ## Commit all outstanding changes in the tree.  Returns the new digest.
    String commit() {
        # If our digest is up to date, we don't need to do anything.
        if (!dirty)
            return digest;

        if (__children) {
            # Commit all dirty children and reconstruct the child list for the
            # underlying node.
            for (child :in __children) {
                if (!child.getDigest())
                    child.setDigest(dig := child.node.commit());
            }
        }

        # Commit the node itself and clear the journal.
        orgDigest := digest;
        if (__children) {
            for (child :in __children) {
                if (!child.entry.hash)
                    throw AssertionError(
                        FStr() `Invalid hash for $(child.getName())`
                    );
            }
        }

        digest = __cache.storeNode(node);
        dirty = false;
        __cache.clearJournal();

        return digest;
    }

    ## Utility class for formatting a Change message.  This is useful for
    ## debugging problems during journal replay.
    class ChangeFormatter {
        CachedNode node;
        Change change;
        oper init(CachedNode node, Change change) :
            node = node,
            change = change {
        }

        void formatChange(Formatter out) {
            if (change.type == CHANGE_ADD_CHILD) {
                out ` add child $(change.name)`;
            } else if (change.type == CHANGE_DELETE_CHILD) {
                out ` delete child $(change.name)`;
            } else if (change.type == CHANGE_WRITE) {
                out ` write\n`;
            } else if (change.type == CHANGE_RESIZE) {
                out ` resize to $(change.newSize)`;
            }
        }

        void formatTo(Formatter out, CachedNode n, int index) {
            if (change.path && index < change.path.count()) {
                n.__populateChildren(true);
                entry := n.__children[change.path[index]];
                out I`$(entry.entry.name)`;
                out `($(change.path[index]))/`;
                if (!entry.node && !entry.entry.hash) {
                    out `<NULL HASH>`;
                    formatChange(out);
                    return;
                }
                formatTo(out, entry.getNode(), ++index);
            } else {
                formatChange(out);
            }
        }

        void formatTo(Formatter out) {
            formatTo(out, node, 0);
        }
    }

    void __applyChange(Change change) {
        if (change.type == CHANGE_ADD_CHILD) {
            __addChild(change.name, change.node);
        } else if (change.type == CHANGE_DELETE_CHILD) {
            if (!__populateChildren(false) || !__children.delete(change.name))
                throw InvalidStateError(
                    FStr() `replaying delete: can't delete child $(change.name)`
                );
            __markDirty();
        } else if (change.type == CHANGE_WRITE) {
            __write(uint64(change.pos), change.data);
        } else if (change.type == CHANGE_RESIZE) {
            __resize(uint64(change.newSize));
        } else {
            error `Unrecognized change type $(change.type)`;
        }
    }

    ## Lookup a change in the descendent tree, return the descendant that the
    ## change applies to.
    CachedNode __lookup(Change change, int index) {
        if (!change || !change.path || index >= change.path.count())
            return this;

        # Get the child index from the path.
        childIndex := change.path[index];
        @assert(node.children && childIndex < node.children.count());
        __populateChildren(false);
        return __children[childIndex].getNode().__lookup(change, index + 1);
    }

    ## Replay all journal entries against the node.  If the node doesn't have
    ## a digest or there are no changes, does nothing.  Should only be used on
    ## the root node.
    void replayJournal() {
        if (parent)
            throw InvalidArgumentError('Replay journal only works against the '
                                        'root node.'
                                       );

        String lastChangeDigest;
        for (entry :in __cache.makeJournalIter()) {
            change := entry.change;
            if (!lastChangeDigest) {
                # First change after a commit.  Verify that the change has a
                # commit hash that matches the last commit.
                if (!change.commit)
                    throw InvalidStateError('First change in the journal '
                                             'does not have a commit field.'
                                            );
                if (change.commit != __cache.baselineCommit)
                    throw InvalidStateError(
                        FStr() I`First change in the journal is for commit \
                                 $(altEncode(change.commit)), current commit \
                                 is $(altEncode(__cache.baselineCommit))`
                    );
            } else if (lastChangeDigest != change.lastChange) {
                throw InvalidStateError(
                    FStr() I`Change $(altEncode(entry.digest)) should be \
                             applied to $(altEncode(change.lastChange)). \
                             last change was $(altEncode(lastChangeDigest)).`
                );
            }
            node := __lookup(change, 0);
            @assert(node);
            node.__applyChange(change);
            lastChangeDigest = entry.digest;
        }

        # Give this to the cache.
        __cache.lastChange = lastChangeDigest;
    }

    uint read(uint64 pos, WriteBuffer buffer) {
        if (pos > node.size)
            return 0;

        buffer.size = 0;
        if (node.contents) {

            # We've got contents, read from there.
            if (pos < node.contents.size) {
                uint size;
                if (buffer.cap >= node.contents.size - pos)
                    size = node.contents.size - pos;
                else
                    size = buffer.cap;
                buffer.move(0, node.contents.buffer + pos,
                            size
                            );
                buffer.size = size;
            } else {
                buffer.size = 0;
            }
        } else if (node.children) {

            WriteBuffer frame = {null, 0, 0};
            for (child :in __children) {
                if (pos < child.getSize()) {

                    # Delegate the operation to the child

                    # Make the frame buffer the remaining part of the input
                    # buffer.
                    frame.buffer = buffer.buffer + buffer.size;
                    frame.cap = buffer.cap - buffer.size;
                    frame.size = 0;

                    # Pass this off to the child.
                    amtRead := child.getNode().read(pos, frame);
                    buffer.size += amtRead;

                    # Quit if we've filled the buffer.
                    if (buffer.size == buffer.cap)
                        break;

                    # Reset pos to zero so we start at the beginning of the
                    # next child.
                    pos = 0;
                } else {
                    # Fix the position to be relative to the start of the next
                    # child.
                    pos -= child.getSize();
                }
            }
        }

        return buffer.size;
    }

    uint64 verify() {

        # If the node isn't dirty, verify that we have a correct digest.
        if (!dirty) {
            @assert(digest);
            @assert(digest == __cache.store.makeDigest(node));
        }

        # XXX add something to verify tree depth.
        if (node.contents) {
            @assert(node.contents.size == node.size);
            @assert(node.contents.size <= __cache.maxContentSize);
            return node.contents.size;
        } else if (node.children) {
            @assert(__populateChildren(false));
            uint64 totalSize;
            for (child :in __children) {
                @assert(child.getSize() == child.getNode().verify());
                @assert(child.getParent() is this);
                @assert(child.getNode().parent is this);
                totalSize += child.getSize();
            }

            return totalSize;
        } else {
            return 0;
        }
    }

    void formatTo(Formatter out) {
        indent := Indenter.wrap(out);
        indent `CachedNode {\n`;
        __populateChildren(false);
        ++indent;
        indent I`hash: $(digest ? altEncode(digest) : 'null')
                 size: $(node.size)
                 contents: $(!(node.contents is null) ?
                                node.contents.getRepr() :
                                'null'
                             )
                 entries: $__children\n`;
        --indent;
        indent `}`;
    }
}

CachedNode _makeCachedNode(CachedNode parent, Cache cache, String digest) {
    node := cache.getNode(digest);
    if (!node)
        return null;

    result := CachedNode(cache, digest, node);
    result.parent = parent;
    return result;
}
