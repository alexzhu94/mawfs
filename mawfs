#!/usr/local/bin/crack

import crack.ascii hex;
#import crack.exp.fuse fuseMain = main, LockedFilesystem, NodeImpl;
import crack.hash Hash;
import crack.hash.sha256 SHA256;
import crack.lang Buffer, Exception, ManagedBuffer, SystemError;

import crack.fs makePath, Path;
import crack.sys argv, exit;
import crack.io cin, cout, cerr, Reader, StringWriter, Writer;

import crack.cont.array Array;
import crack.lang cmp, makeHashVal, AppendBuffer;
import crack.protobuf Field, Message, ProtoWriter;
import crack.crypt.ssl.cipher EVP_aes_256_cbc, DecryptWriter, EncryptWriter;

@import crack.ann impl;


@import crack.protobuf.ann protobuf;

@protobuf {
    ## A filesystem entry.
    message Entry {
        ## The sha1 hash of the encrypted object.
        required bytes hash = 1;

        ## The name of the object.
        required string name = 2;

        ## The 32 bit checksum of the original file (calculated by adding
        ## bytes).
        optional int32 org_checksum = 3;
    }

    message Directory {
        repeated Entry entry = 1;
    }
}

String _hashFile(Path file) {
    src := file.makeFullReader();
    hasher := SHA256();
    buffer := ManagedBuffer(4096);
    uint64 size;
#    while (rc := src.read(buffer)) {
#        size += rc;
#        cout `\r$size\033[k`;
#        hasher.update(buffer);
#    }
    hasher.update(src.readAll());
    cout `\n`;
    return hasher.digest();
}

## A chunk is the basic unit of data in MAWFS.  We store its content and
## the digest of its encrypted representation.
class Chunk {
    String contents;
    String digest;

    oper init(String contents, String digeset) :
        contents = contents,
        digest = digest {
    }
}

# Size of blocks to read and write.
const BLOCK_SIZE := 65536;

class BadDigestError : Exception {
    oper init() {}
    oper init(String message) : Exception(message) {}
}

class HashAndWrite @impl Writer {

    Hash hasher;
    Writer dst;

    oper init(Hash hasher, Writer dst) :
        hasher = hasher,
        dst = dst {
    }

    void write(Buffer data) {
        hasher.update(data);
        dst.write(data);
    }

    String getDigest() { return hasher.digest(); }
}

## Information on a MAWFS filesystem.
class FSInfo {
    String password;

    oper init(String password) : password = password {}

    ## Reads a "Chunk" from a Reader.  A chunk is the basic unit of data.  The
    ## reader is assumed to be an encrypted stream
    Chunk readChunk(Reader src) {
        hasher := SHA256();
        back := StringWriter();
        decrypter := DecryptWriter(EVP_aes_256_cbc(), password, back);
        while (data := src.read(BLOCK_SIZE)) {
            hasher.update(data);
            decrypter.write(data);
        }

        decrypter.close();

        return Chunk(back.string(), hasher.digest());
    }

    ## Writes and encrypts raw chunk data, returns the digest of the encrypted
    ## data.
    String writeChunk(Writer dst, Buffer data) {
        temp := Buffer(null, 0);
        uint cur;
        HashAndWrite back = {SHA256(), dst};
        encrypter := EncryptWriter(EVP_aes_256_cbc(), password, back);
        while (cur < data.size) {
            temp.size = (data.size - cur > BLOCK_SIZE) ? BLOCK_SIZE :
                                                         data.size - cur;
            temp.buffer = data.buffer + cur;
            encrypter.write(temp);
            cur += temp.size;
        }

        encrypter.close();
        return back.getDigest();
    }

    ## Writes and encrypts a chunk and verifies the digest.  If the digest
    ## doesn't match that of the chunk, throws a BadDigestError.
    void writeChunk(Writer dst, Chunk chunk) {
        if (writeChunk(dst, chunk.contents) != chunk.digest)
            throw BadDigestError();
    }

}

#class DirNode : NodeImpl {
#    @static DirNode readFrom(Reader src) {

#void mount(String backing, String mountPoint) {
#
#    backingRoot := makePath(backing);
#    fuseMain(StringArray!['<mawfs>', mountPoint], LockedFilesystem(backingRoot));
#    # xxxx finish writing xxxxx
#}

const TESTPW := 'FooBar-boguspassFooBar-boguspass';

void usage() {
    cerr I`\
        Usage:
            mawfs hash <filename> ...
                Show file hashes.
            mawfs mount <backing-store> <mount-point>
                Mount a filesystem.
            mawfs storechunk <src-file>
                Reads data from <src-file> and writes it to the filesystem
                under its digest name.
            mawfs loadchunk <hash>
                Loads a chunk based on its digest and writes it to standard
                output.
        `;
}

Reader getReader(String filename) {
    if (filename == '-') {
        return cin;
    } else {
        return makePath(filename).reader();
    }
}

void main() {
    if (argv.count() < 2) {
        usage();
        exit(1);
    }

    try {
        cmd := argv[1];
        if (cmd == 'hash') {
            if (argv.count() < 3) {
                cerr `No files specified\n`;
                exit(1);
            }
            for (file :in argv.subarray(2))
                cout `$(hex(_hashFile(makePath(file)))) $file\n`;
        } else if (cmd == 'mount') {
            if (argv.count() != 4) {
                cerr `Usage: mawfs mount <backing-store> <mount-point>\n`;
                exit(1);
            }

#            mount(argv[2], argv[3]);
        } else if (cmd == 'storechunk') {
            if (argv.count() != 3) {
                cerr `Usage: mawfs storechunk <src-file>`;
                exit(1);
            }

            fs := FSInfo(TESTPW);
            src := getReader(argv[2]);
            outPath := makePath('out.tmp');
            tmpOut := outPath.writer();

            # Read the file contents.
            contents := AppendBuffer(BLOCK_SIZE);
            while (data := src.read(BLOCK_SIZE))
                contents.extend(data);

            digest := hex(fs.writeChunk(tmpOut, contents));
            outPath.moveTo(makePath(digest));
            cout `$digest\n`;
        } else if (cmd == 'loadchunk') {
            if (argv.count() != 3) {
                cerr `Usage: mawfs loadchunk <hash>\n`;
                exit(1);
            }

            fs := FSInfo(TESTPW);
            chunk := fs.readChunk(makePath(argv[2]).reader());
            cout `$(chunk.contents)`;
        } else {
            cerr `Unknown command: $cmd\n`;
            usage();
            exit(1);
        }
    } catch (SystemError ex) {
        cerr `$(ex.text)\n`;
    }
}

main();
